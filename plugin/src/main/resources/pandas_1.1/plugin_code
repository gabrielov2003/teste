
from typing import Union, Any
from hashlib import blake2b
from pandas import DataFrame
from pandas.io.formats.style import Styler


def create_fingerprint(frame_or_styler: Union[DataFrame, Styler], org_data_source: Any = None) -> str:
    frame = frame_or_styler if isinstance(frame_or_styler, DataFrame) else frame_or_styler.data
    fingerprint_input = [
        id(org_data_source if org_data_source is not None else frame),
        frame.shape,
        frame.index[:60],
        frame.dtypes[:60]
    ]
    return blake2b('-'.join(str(x) for x in fingerprint_input).encode(), digest_size=16).hexdigest()

import json
from dataclasses import is_dataclass, asdict
from typing import Any


class CustomJSONEncoder(json.JSONEncoder):
    def default(self, obj: Any):
        if is_dataclass(obj):
            return asdict(obj)
        return str(obj)

import inspect
from dataclasses import dataclass
from functools import partial
from typing import Tuple, Callable, Optional, Union, Any
from pandas._typing import Axis


@dataclass(frozen=True)
class ApplyMapArgs:
    style_func: Callable
    subset: Optional[Any]

    @classmethod
    def from_tuple(cls, args: Tuple[Callable, Optional[Any]]):
        return cls(args[0], args[1])

    @staticmethod
    def copy_with(style_func: Callable, subset: Optional[Any]):
        return ApplyMapArgs(style_func, subset)

    def to_tuple(self) -> Tuple[Callable, Optional[Any]]:
        return self.style_func, self.subset


@dataclass(frozen=True)
class ApplyArgs:
    style_func: Callable
    axis: Optional[Axis]
    subset: Optional[Any]

    @classmethod
    def from_tuple(cls, args: Tuple[Callable, Optional[Axis], Optional[Any]]):
        return cls(args[0], args[1], args[2])

    def copy_with(self, style_func: Callable, subset: Optional[Any]):
        return ApplyArgs(style_func, self.axis, subset)

    def to_tuple(self) -> Tuple[Callable, Optional[Axis], Optional[Any]]:
        return self.style_func, self.axis, self.subset


@dataclass(frozen=True)
class StylerTodo:
    apply_func: Callable
    apply_args: Union[ApplyArgs, ApplyMapArgs]
    style_func_kwargs: dict

    @classmethod
    def from_tuple(cls, todo: Tuple[Callable, tuple, dict]):
        return cls(todo[0], cls._to_apply_args(todo), todo[2])

    def builder(self):
        return StylerTodoBuilder(self)

    @staticmethod
    def _to_apply_args(todo: Tuple[Callable, tuple, dict]):
        if StylerTodo.is_applymap_tuple(todo):
            return ApplyMapArgs.from_tuple(todo[1])
        else:
            return ApplyArgs.from_tuple(todo[1])

    @classmethod
    def is_applymap_tuple(cls, todo: Tuple[Callable, tuple, dict]):
        return cls.__is_apply_map_func(todo[0])

    def is_applymap(self) -> bool:
        return self.__is_apply_map_func(self.apply_func)

    @staticmethod
    def __is_apply_map_func(func: Callable) -> bool:
        return getattr(func, '__qualname__', '').startswith('Styler.applymap')

    def is_pandas_style_func(self) -> bool:
        func = self.apply_args.style_func
        if isinstance(func, partial):
            func = func.func
        inspect_result = inspect.getmodule(func)
        return False if inspect_result is None else inspect.getmodule(func).__name__ == 'pandas.io.formats.style'

    def should_provide_chunk_parent(self):
        sig = inspect.signature(self.apply_args.style_func)
        for param in sig.parameters.values():
            if param.name == "chunk_parent" or param.kind == inspect.Parameter.VAR_KEYWORD:
                return True
        return False

    def to_tuple(self) -> Tuple[Callable, tuple, dict]:
        return self.apply_func, self.apply_args.to_tuple(), self.style_func_kwargs


class StylerTodoBuilder:

    def __init__(self, source: StylerTodo):
        self.source: StylerTodo = source
        self.values: dict = {}

    def with_subset(self, subset: Optional[Any]):
        self.values["subset"] = subset
        return self

    def with_style_func(self, style_func: Callable):
        self.values["style_func"] = style_func
        return self

    def with_style_func_kwargs(self, style_func_kwargs: dict):
        self.values["style_func_kwargs"] = style_func_kwargs
        return self

    def build(self) -> StylerTodo:
        return StylerTodo(
            self.source.apply_func,
            self.source.apply_args.copy_with(
                style_func=self.values.get("style_func", self.source.apply_args.style_func),
                subset=self.values.get("subset", self.source.apply_args.subset),
            ),
            self.values.get("style_func_kwargs", self.source.style_func_kwargs),
        )

from functools import partial


class StyleFunctionNameResolver:

    @staticmethod
    def get_style_func_qname(todo: StylerTodo) -> str:
        func = todo.apply_args.style_func
        if isinstance(func, partial):
            func = func.func
        return getattr(func, '__qualname__', '')

    @staticmethod
    def resolve_style_func_name(todo: StylerTodo) -> str:
        qname = StyleFunctionNameResolver.get_style_func_qname(todo)
        if todo.is_pandas_style_func():
            if StyleFunctionNameResolver.is_pandas_background_gradient(qname):
                return "background_gradient"
            elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):
                return "highlight_max"
            elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):
                return "highlight_min"
            elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):
                return "highlight_null"
            elif StyleFunctionNameResolver.is_pandas_set_properties(qname):
                return "set_properties"
            else:
                return qname.rpartition('.')[2]
        else:
            return qname.rpartition('.')[2]

    @staticmethod
    def is_pandas_background_gradient(style_func_qname: str) -> bool:
        return style_func_qname == 'Styler._background_gradient'

    @staticmethod
    def is_pandas_highlight_max(style_func_qname: str, todo: StylerTodo) -> bool:
        return style_func_qname.startswith('Styler._highlight_extrema') and todo.style_func_kwargs.get('max_', False)

    @staticmethod
    def is_pandas_highlight_min(style_func_qname: str, todo: StylerTodo) -> bool:
        return style_func_qname.startswith('Styler._highlight_extrema') and not todo.style_func_kwargs.get('max_', False)

    @staticmethod
    def is_pandas_highlight_null(style_func_qname: str) -> bool:
        return style_func_qname.startswith('Styler._highlight_null')

    @staticmethod
    def is_pandas_set_properties(style_func_qname: str) -> bool:
        return style_func_qname.startswith('Styler.set_properties')

from abc import ABC, abstractmethod
from typing import Optional, Any

from pandas import DataFrame
from pandas.core.indexing import _non_reducing_slice


class TodoPatcher(ABC):

    def __init__(self, todo: StylerTodo):
        self._todo: StylerTodo = todo

    @abstractmethod
    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:
        pass

    @staticmethod
    def _calculate_chunk_subset(org_subset_frame: DataFrame, chunk: DataFrame) -> Any:
        index_intersection = chunk.index.intersection(org_subset_frame.index)
        column_intersection = chunk.columns.intersection(org_subset_frame.columns)
        return index_intersection, column_intersection

    @staticmethod
    def _create_subset_frame(org_frame: DataFrame, subset: Optional[Any]) -> DataFrame:
        subset = slice(None) if subset is None else subset
        subset = _non_reducing_slice(subset)
        return org_frame.loc[subset]

from typing import Optional
from pandas import DataFrame


class ApplyMapPatcher(TodoPatcher):

    def __init__(self, todo: StylerTodo):
        super().__init__(todo)

    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:
        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)
        return self._todo.builder() \
            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \
            .build()

from typing import Optional, Union

from pandas import DataFrame, Series


class ApplyPatcher(TodoPatcher):

    def __init__(self, todo: StylerTodo):
        super().__init__(todo)

    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:
        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)
        builder = self._todo.builder().with_subset(self._calculate_chunk_subset(subset_frame, chunk))
        if self._todo.should_provide_chunk_parent():
            builder.with_style_func(
                ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame),
            )
        else:
            builder.with_style_func(self._styling_func)
        return builder.build()

    def _styling_func(self, chunk_or_series_from_chunk: Union[DataFrame, Series], **kwargs):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk
        return self._todo.apply_args.style_func(chunk_or_series_from_chunk, **kwargs)

from typing import Optional, Union

import numpy as np
from pandas import DataFrame, Series


class BackgroundGradientPatcher(TodoPatcher):

    def __init__(self, todo: StylerTodo):
        super().__init__(todo)

    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:
        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)
        return self._todo.builder() \
            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \
            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame)) \
            .build()

    def _styling_func(self,
                      chunk_or_series_from_chunk: Union[DataFrame, Series],
                      chunk_parent: Union[DataFrame, Series],
                      **kwargs,
                      ):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        vmin = kwargs.get("vmin", None)
        vmax = kwargs.get("vmax", None)

        if vmin is None or vmax is None:
            n = chunk_parent.to_numpy()
            if vmin is None:
                vmin = np.nanmin(n)
            if vmax is None:
                vmax = np.nanmax(n)

        return self._todo.apply_args.style_func(
            chunk_or_series_from_chunk,
            **dict(kwargs, vmin=vmin, vmax=vmax),
        )

from typing import Callable, Optional, Union

from pandas import DataFrame, Series
from pandas._typing import Axis


class ChunkParentProvider:
    def __init__(self, style_func: Callable, axis: Optional[Axis], subset_frame: DataFrame):
        self.__style_func = style_func
        self.__axis = axis
        self.__subset_frame = subset_frame

    def __call__(self, chunk_or_series_from_chunk: Union[DataFrame, Series], *args, **kwargs):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        kwargs['chunk_parent'] = self._get_parent(chunk_or_series_from_chunk)
        return self.__style_func(chunk_or_series_from_chunk, *args, **kwargs)

    def _get_parent(self, chunk_or_series_from_chunk: Union[DataFrame, Series]):
        if self.__axis == 0 or self.__axis == "index":
            return self.__subset_frame[chunk_or_series_from_chunk.name]
        elif self.__axis == 1 or self.__axis == "columns":
            return self.__subset_frame.loc[chunk_or_series_from_chunk.name]
        else:
            return self.__subset_frame

import numpy as np
from typing import Optional, Union
from pandas import DataFrame, Series


class HighlightExtremaPatcher(TodoPatcher):

    def __init__(self, todo: StylerTodo):
        super().__init__(todo)
        self._max: bool = todo.style_func_kwargs.get('max_', False)
        self._attribute: str = f"background-color: {todo.style_func_kwargs.get('color', 'yellow')}"

    def create_patched_todo(self, org_frame: DataFrame, chunk: DataFrame) -> Optional[StylerTodo]:
        subset_frame = self._create_subset_frame(org_frame, self._todo.apply_args.subset)
        return self._todo.builder() \
            .with_subset(self._calculate_chunk_subset(subset_frame, chunk)) \
            .with_style_func_kwargs({}) \
            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, subset_frame)) \
            .build()

    def _styling_func(self,
                      chunk_or_series_from_chunk: Union[DataFrame, Series],
                      chunk_parent: Union[DataFrame, Series],
                      ):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        if self._max:
            extrema = chunk_or_series_from_chunk == np.nanmax(chunk_parent.to_numpy())
        else:
            extrema = chunk_or_series_from_chunk == np.nanmin(chunk_parent.to_numpy())

        if chunk_or_series_from_chunk.ndim == 1:
            return [self._attribute if v else "" for v in extrema]
        else:
            return DataFrame(
                np.where(extrema, self._attribute, ""),
                index=chunk_or_series_from_chunk.index,
                columns=chunk_or_series_from_chunk.columns
            )

from typing import Callable, List, Tuple, Optional

from pandas import DataFrame


class TodosPatcher:

    def patch_todos_for_chunk(self,
                              todos: List[StylerTodo],
                              org_frame: DataFrame,
                              chunk: DataFrame,
                              ) -> List[Tuple[Callable, tuple, dict]]:
        result: List[Tuple[Callable, tuple, dict]] = []

        for t in todos:

            if t.is_pandas_style_func():
                patcher = self.__get_patcher_for_pandas_style_function(t)
            else:
                if t.is_applymap():
                    patcher = ApplyMapPatcher(t)
                else:
                    patcher = ApplyPatcher(t)

            if patcher is not None:
                result.append(patcher.create_patched_todo(org_frame, chunk).to_tuple())

        return result

    @staticmethod
    def is_style_function_supported(todo: StylerTodo) -> bool:
        if todo.is_pandas_style_func():
            return TodosPatcher.__get_patcher_for_pandas_style_function(todo) is not None
        return True

    @staticmethod
    def __get_patcher_for_pandas_style_function(todo: StylerTodo) -> Optional[TodoPatcher]:
        qname = StyleFunctionNameResolver.get_style_func_qname(todo)
        if StyleFunctionNameResolver.is_pandas_background_gradient(qname):
            return BackgroundGradientPatcher(todo)
        elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):
            return HighlightExtremaPatcher(todo)
        elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):
            return HighlightExtremaPatcher(todo)
        elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):
            return ApplyMapPatcher(todo)
        elif StyleFunctionNameResolver.is_pandas_set_properties(qname):
            return ApplyMapPatcher(todo)
        return None

from abc import ABC, abstractmethod
from typing import List, Optional, Tuple, Callable, Any
from dataclasses import dataclass
import numpy as np
from pandas import DataFrame, Index
from pandas.io.formats.style import Styler
from pandas.core.indexing import _non_reducing_slice


class IndexTranslator(ABC):
    @abstractmethod
    def translate(self, index):
        pass


class _SequenceIndexTranslator(IndexTranslator):
    def __init__(self, seq):
        super().__init__()
        self.__seq = seq

    def translate(self, index):
        return self.__seq[index]


class _OffsetIndexTranslator(IndexTranslator):
    def __init__(self, offset: int):
        super().__init__()
        self.__offset = offset

    def translate(self, index):
        return index + self.__offset


@dataclass(frozen=True)
class Region:
    first_row: int = 0
    first_col: int = 0
    rows: int = 0
    cols: int = 0

    def is_empty(self) -> bool:
        return self.rows == 0 or self.cols == 0

    def is_valid(self) -> bool:
        return self.first_row >= 0 and self.first_col >= 0 and self.rows >= 0 and self.cols >= 0

    def iterate_chunkwise(self, rows_per_chunk: int, cols_per_chunk: int):
        rows_processed = 0
        while rows_processed < self.rows:
            rows = min(rows_per_chunk, self.rows - rows_processed)
            cols_in_row_processed = 0
            while cols_in_row_processed < self.cols:
                cols = min(cols_per_chunk, self.cols - cols_in_row_processed)

                yield Region(rows_processed, cols_in_row_processed, rows, cols)

                cols_in_row_processed += cols
            rows_processed += rows


@dataclass(frozen=True)
class SortCriteria:
    by_column: Optional[List[int]] = None
    ascending: Optional[List[bool]] = None

    def is_empty(self) -> bool:
        return self.by_column is None or len(self.by_column) == 0

    def __eq__(self, other):
        if isinstance(other, SortCriteria):
            def _equals(s: Optional[List[Any]], o: Optional[List[Any]]) -> bool:
                s_len = 0 if s is None else len(s)
                o_len = 0 if o is None else len(o)
                return (s_len + o_len == 0) or s == o

            return _equals(self.by_column, other.by_column) and _equals(self.ascending, other.ascending)
        return False


@dataclass(frozen=True)
class FilterCriteria:
    index: Optional[Index] = None
    columns: Optional[Index] = None

    @staticmethod
    def from_frame(frame: Optional[DataFrame]):
        return None if frame is None else FilterCriteria(frame.index, frame.columns)

    def is_empty(self) -> bool:
        return self.index is None and self.columns is None

    def __eq__(self, other):
        if isinstance(other, FilterCriteria):
            def _equals(s: Optional[Index], o: Optional[Index]) -> bool:
                if s is None and o is None:
                    return True
                return s is not None and o is not None and s.equals(o)
            return _equals(self.columns, other.columns) and _equals(self.index, other.index)
        return False


class PatchedStylerContext:
    def __init__(self, styler: Styler, filter_criteria: Optional[FilterCriteria] = None):
        self.__styler: Styler = styler
        self.__styler_todos: List[StylerTodo] = [StylerTodo.from_tuple(t) for t in styler._todo]
        self.__sort_criteria: SortCriteria = SortCriteria()
        self.__filter_criteria: FilterCriteria = filter_criteria if filter_criteria is not None else FilterCriteria()

        self.__recompute_visible_frame()

    def is_filtered(self):
        return not self.__filter_criteria.is_empty()

    def set_sort_criteria(self, sort_by_column_index: Optional[List[int]], sort_ascending: Optional[List[bool]]):
        self.__sort_criteria = SortCriteria(sort_by_column_index, sort_ascending)
        self.__recompute_visible_frame()

    def get_org_indices_of_visible_columns(self, part_start: int, max_columns: int) -> np.ndarray:
        part = self.__visible_frame.columns[part_start:part_start + max_columns]
        return self.__styler.columns.get_indexer_for(part)

    def get_region_of_visible_frame(self) -> Region:
        return self.__visible_region

    def compute_visible_intersection(self, region: Region) -> Region:
        if region.is_empty():
            return region
        if self.__visible_region.is_empty():
            return self.__visible_region
        assert region.is_valid()
        first_row = min(region.first_row, self.__visible_region.rows - 1)
        first_col = min(region.first_col, self.__visible_region.cols - 1)
        rows_left = self.__visible_region.rows - (0 if first_row == 0 else first_row + 1)
        cols_left = self.__visible_region.cols - (0 if first_col == 0 else first_col + 1)
        rows = min(region.rows, rows_left)
        cols = min(region.cols, cols_left)
        return Region(first_row, first_col, rows, cols)

    def get_visible_frame(self) -> DataFrame:
        return self.__visible_frame

    def get_styler(self) -> Styler:
        return self.__styler

    def get_styler_todos(self) -> List[StylerTodo]:
        if self.__styler_todos is None:
            self.__styler_todos = [StylerTodo.from_tuple(t) for t in self.__styler._todo]
        return self.__styler_todos

    def create_patched_todos(self,
                             chunk: DataFrame,
                             todos_filter: Optional[Callable[[StylerTodo], bool]] = None,
                             ) -> List[Tuple[Callable, tuple, dict]]:
        all_todos = self.get_styler_todos()
        filtered_todos = all_todos if todos_filter is None else list(filter(todos_filter, all_todos))
        return TodosPatcher().patch_todos_for_chunk(filtered_todos, self.__styler.data, chunk)

    def get_row_index_translator_for_chunk(self, chunk: DataFrame, chunk_region: Region) -> IndexTranslator:
        if self.__sort_criteria.is_empty() and self.__filter_criteria.index is None:
            return _OffsetIndexTranslator(chunk_region.first_row)
        return _SequenceIndexTranslator(self.__styler.index.get_indexer_for(chunk.index))

    def get_column_index_translator_for_chunk(self, chunk: DataFrame, chunk_region: Region) -> IndexTranslator:
        if self.__filter_criteria.columns is None and len(self.__styler.hidden_columns) == 0:
            return _OffsetIndexTranslator(chunk_region.first_col)
        return _SequenceIndexTranslator(self.__styler.columns.get_indexer_for(chunk.columns))

    def __recompute_visible_frame(self):
        self.__visible_frame = self.__sort_frame(
            self.__filter_frame(self.__frame_without_hidden_rows_and_cols(self.__styler)),
        )
        self.__visible_region = Region(0, 0, len(self.__visible_frame.index), len(self.__visible_frame.columns))

    def __sort_frame(self, frame: DataFrame) -> DataFrame:
        if self.__sort_criteria.is_empty():
            return frame
        sc = self.__sort_criteria
        return frame.sort_values(
            by=[frame.columns[i] for i in sc.by_column],
            ascending=True if sc.ascending is None or len(sc.ascending) == 0 else sc.ascending,
        )

    def __filter_frame(self, frame: DataFrame) -> DataFrame:
        if self.__filter_criteria.is_empty():
            return frame
        else:
            fc = self.__filter_criteria
            index_intersection = frame.index if fc.index is None else frame.index.intersection(fc.index)
            column_intersection = frame.columns if fc.columns is None else frame.columns.intersection(fc.columns)
            subset = index_intersection, column_intersection
            subset = slice(None) if subset is None else subset
            subset = _non_reducing_slice(subset)
            return frame.loc[subset]

    @staticmethod
    def __frame_without_hidden_rows_and_cols(styler: Styler) -> DataFrame:
        if len(styler.hidden_columns) == 0:
            return styler.data
        else:
            visible_columns = np.delete(styler.columns.get_indexer_for(styler.columns), styler.hidden_columns)
            return styler.data.iloc[:, visible_columns]

from collections.abc import Mapping
from dataclasses import dataclass
from typing import Optional, Callable, List, Set, Dict, Tuple, Any
from pandas.io.formats.style import Styler
from pandas.io.formats.printing import pprint_thing


@dataclass
class TableFrameCell:
    value: str
    css: Dict[str, str] = None


@dataclass
class TableFrameLegend:
    index: List[str]
    column: List[str]


@dataclass
class TableFrame:
    index_labels: List[List[str]]
    column_labels: List[List[str]]
    cells: List[List[TableFrameCell]]
    legend: Optional[TableFrameLegend] = None


@dataclass
class _CSSPropsWithIndex:
    props: Dict[str, str]
    index: int


@dataclass
class _SpannedElement:
    row_span: int
    col_span: int
    element: dict


class _TranslateKeysDict(Mapping, dict):

    def __init__(self, org_dict: dict, translate_key: Callable):
        self._org_dict = org_dict
        self._translate_key = translate_key

    def get(self, key, default=None):
        t_key = self._translate_key(key)
        if t_key not in self._org_dict:
            return default
        return self._org_dict.get(t_key)

    def __contains__(self, key):
        return self._translate_key(key) in self._org_dict

    def __getitem__(self, key):
        return self._org_dict[self._translate_key(key)]

    def values(self):
        return super().values()

    def __iter__(self):
        raise NotImplementedError

    def keys(self):
        raise NotImplementedError

    def items(self):
        raise NotImplementedError

    def __len__(self):
        return len(self._org_dict)


class ValueFormatter:

    @staticmethod
    def format_column(value: Any) -> str:
        return pprint_thing(value)

    @staticmethod
    def format_index(value: Any) -> str:
        return pprint_thing(value)

    @staticmethod
    def format_cell(value: Any) -> str:
        return pprint_thing(value, quote_strings=True, max_seq_items=42)


class TableFrameGenerator:
    def __init__(self,
                 styler_context: PatchedStylerContext,
                 todos_filter: Optional[Callable[[StylerTodo], bool]] = None,
                 ):
        self.__styler_context: PatchedStylerContext = styler_context
        self.__todos_filter: Optional[Callable[[StylerTodo], bool]] = todos_filter

    def generate_by_combining_chunks(self,
                                     rows_per_chunk: int,
                                     cols_per_chunk: int,
                                     region: Region = None,
                                     ) -> TableFrame:
        result = None

        if region is None:
            region = self.__styler_context.get_region_of_visible_frame()

        for chunk_region in region.iterate_chunkwise(rows_per_chunk, cols_per_chunk):

            exclude_row_header = chunk_region.first_col > 0
            exclude_col_header = chunk_region.first_row > 0

            chunk_table = self.generate(
                region=Region(
                    region.first_row + chunk_region.first_row,
                    region.first_col + chunk_region.first_col,
                    chunk_region.rows,
                    chunk_region.cols,
                ),
                exclude_row_header=exclude_row_header,
                exclude_col_header=exclude_col_header,
            )

            if result is None:
                result = chunk_table
            else:
                if not exclude_col_header:
                    result.column_labels.extend(chunk_table.column_labels)
                if not exclude_row_header:
                    result.index_labels.extend(chunk_table.index_labels)
                    result.cells.extend(chunk_table.cells)
                else:
                    for i, row in enumerate(chunk_table.cells):
                        result.cells[i + chunk_region.first_row].extend(row)

        return result if result is not None else TableFrame(index_labels=[], column_labels=[], legend=None, cells=[])

    def generate(self,
                 region: Region = None,
                 exclude_row_header: bool = False,
                 exclude_col_header: bool = False,
                 ) -> TableFrame:
        if region is None:
            region = self.__styler_context.get_region_of_visible_frame()

        chunk = self.__styler_context.get_visible_frame().iloc[
                region.first_row: region.first_row + region.rows,
                region.first_col: region.first_col + region.cols,
                ]

        chunk_aware_todos = self.__styler_context.create_patched_todos(chunk, self.__todos_filter)

        computed_styler = self.__compute_styling(
            chunk_aware_todos=chunk_aware_todos,
            exclude_row_header=exclude_row_header,
        )

        chunk_styler = chunk.style
        self.__copy_styler_state(source=computed_styler, target=chunk_styler)

        rit = self.__styler_context.get_row_index_translator_for_chunk(chunk, region)
        cit = self.__styler_context.get_column_index_translator_for_chunk(chunk, region)

        def translate_key(k):
            return rit.translate(k[0]), cit.translate(k[1])

        chunk_styler.ctx = _TranslateKeysDict(computed_styler.ctx, translate_key)
        chunk_styler._display_funcs = _TranslateKeysDict(computed_styler._display_funcs, translate_key)

        html_props = chunk_styler._translate()

        return self._convert_to_table_frame(
            html_props,
            exclude_row_header=exclude_row_header,
            exclude_col_header=exclude_col_header,
            formatter=ValueFormatter(),
        )

    def __compute_styling(self,
                          chunk_aware_todos: List[Tuple[Callable, tuple, dict]],
                          exclude_row_header: bool = False,
                          ) -> Styler:
        styler = self.__styler_context.get_styler()

        copy = styler.data.style
        self.__copy_styler_state(source=styler, target=copy)

        copy._todo = chunk_aware_todos

        if exclude_row_header:
            copy.hide_index()

        copy._compute()
        return copy

    @staticmethod
    def __copy_styler_state(source: Styler, target: Styler):
        target.uuid = ''
        target.uuid_len = 0
        target.cell_ids = False

        target.table_styles = source.table_styles
        target.table_attributes = source.table_attributes
        target.hidden_index = source.hidden_index
        target._display_funcs = source._display_funcs

    def _convert_to_table_frame(self,
                                html_props: dict,
                                exclude_row_header: bool,
                                exclude_col_header: bool,
                                formatter: ValueFormatter,
                                ) -> TableFrame:

        self._resolve_spans(html_props, "head")
        self._resolve_spans(html_props, "body")

        column_labels = [] if exclude_col_header else self._extract_column_header_labels(html_props, formatter)
        index_labels = [] if exclude_row_header else self._extract_index_header_labels(html_props, formatter)
        cell_values = self._extract_cell_values(html_props, formatter)
        legend_label = None if exclude_col_header and exclude_row_header else self._extract_legend_label(html_props, formatter)

        return TableFrame(
            index_labels=index_labels,
            column_labels=column_labels,
            legend=legend_label,
            cells=cell_values,
        )

    def _resolve_spans(self, html_props: dict, rows_key: str):
        open_spans: Dict[int, List[_SpannedElement]] = {}

        rows = html_props.get(rows_key, [])
        for ri, row in enumerate(rows):
            updated_row = []
            for ci, element in enumerate(row):
                element_to_add = element
                spanned_element = self.__create_spanned_element_from_span_attributes(element)
                if spanned_element is not None:
                    element_to_add = None
                    open_spans.setdefault(ci, []).append(spanned_element)

                if ci in open_spans:
                    pending_col_spans = open_spans[ci]
                    remove_consumed_spans = False
                    for pending_span in pending_col_spans:
                        updated_row.extend(pending_span.col_span * [pending_span.element])
                        pending_span.row_span -= 1
                        if pending_span.row_span < 1:
                            remove_consumed_spans = True

                    if remove_consumed_spans:
                        cleaned = [s for s in pending_col_spans if s.row_span > 0]
                        if len(cleaned) == 0:
                            del open_spans[ci]
                        else:
                            open_spans[ci] = cleaned

                if element_to_add is not None:
                    updated_row.append(element_to_add)

            rows[ri] = updated_row

    def __create_spanned_element_from_span_attributes(self, element: dict) -> Optional[_SpannedElement]:
        attributes = self.__extract_attributes(element)
        if attributes is None:
            return None

        rowspan = attributes.get("rowspan", None)
        colspan = attributes.get("colspan", None)
        if rowspan is None and colspan is None:
            return None

        element["attributes"] = ''

        rowspan = 1 if rowspan is None else int(rowspan)
        colspan = 1 if colspan is None else int(colspan)
        if rowspan > 1 or colspan > 1:
            return _SpannedElement(rowspan, colspan, element)

        return None

    @staticmethod
    def __extract_attributes(element: dict) -> Optional[Dict[str, str]]:
        attributes = element.get("attributes", '')  # empty attributes can be defined as an empty string instead of list
        if not attributes or attributes == '':
            return None
        if isinstance(attributes, list):
            attributes_dict = {}
            for attr in attributes:
                key, value = attr.split("=")
                attributes_dict[key] = value.strip('"')
            return attributes_dict
        return None

    @staticmethod
    def _extract_legend_label(html_props: dict, formatter: ValueFormatter) -> TableFrameLegend:
        index_legend = []
        column_legend = []

        head = html_props.get("head", [])
        if head:
            last_row = head[-1]

            for element in last_row:
                element_classes = set(element.get("class", "").split(" "))
                if element.get("is_visible", True):
                    if "index_name" in element_classes:
                        display_value = element.get("display_value", element.get("value", ""))
                        if not isinstance(display_value, str):
                            display_value = formatter.format_index(display_value)
                        index_legend.append(display_value)
                if "col_heading" in element_classes:
                    index_legend = []
                    break

            other_rows = head if not index_legend else head[:-1]
            for row in other_rows:

                for element in row:
                    if element.get("is_visible", True):
                        element_classes = set(element.get("class", "").split(" "))
                        is_index_name = "index_name" in element_classes

                        if is_index_name:
                            display_value = element.get("display_value", element.get("value", ""))
                            if not isinstance(display_value, str):
                                display_value = formatter.format_index(display_value)
                            column_legend.append(display_value)
                            break

        return TableFrameLegend(index=index_legend, column=column_legend) if index_legend or column_legend else None

    @staticmethod
    def _extract_column_header_labels(html_props: dict, formatter: ValueFormatter) -> List[List[str]]:
        result: List[List[str]] = []

        for row in html_props.get("head", []):

            is_first_row = not result
            col_heading_index = 0

            for element in row:
                if element.get("is_visible", True):
                    element_classes = set(element.get("class", "").split(" "))
                    is_column_header = "col_heading" in element_classes

                    if is_column_header:
                        display_value = element.get("display_value", "")
                        if not isinstance(display_value, str):
                            display_value = formatter.format_column(display_value)
                        if is_first_row:
                            result.append([display_value])
                        else:
                            result[col_heading_index].append(display_value)
                        col_heading_index += 1

        return result

    @staticmethod
    def _extract_index_header_labels(html_props: dict, formatter: ValueFormatter) -> List[List[str]]:
        result: List[List[str]] = []

        for row in html_props.get("body", []):

            index_label = []

            for element in row:
                if element.get("type", "") == "td":
                    break
                if element.get("is_visible", True):
                    element_classes = set(element.get("class", "").split(" "))
                    is_index_header = "row_heading" in element_classes

                    if is_index_header:
                        display_value = element.get("display_value", "")
                        if not isinstance(display_value, str):
                            display_value = formatter.format_index(display_value)
                        index_label.append(display_value)

            if index_label:
                result.append(index_label)

        return result

    def _extract_cell_values(self, html_props: dict, formatter: ValueFormatter) -> List[List[TableFrameCell]]:
        result: List[List[TableFrameCell]] = []

        css_dict = self.__create_css_dict(html_props)

        for row in html_props.get("body", []):

            cells_in_row = []

            for element in row:

                if element.get("type", "") == "td" and element.get("is_visible", True):
                    element_classes = set(element.get("class", "").split(" "))

                    if "data" in element_classes:
                        display_value = element.get("display_value", "")
                        if not isinstance(display_value, str):
                            display_value = formatter.format_cell(display_value)
                        cells_in_row.append(
                            TableFrameCell(
                                value=display_value,
                                css=self._get_css_dict(element.get("id", None), element_classes, css_dict),
                            ),
                        )

            if cells_in_row:
                result.append(cells_in_row)

        return result

    @staticmethod
    def _get_css_dict(element_id: str, element_classes: Set[str], css_dict: Dict[str, _CSSPropsWithIndex]) -> \
            Optional[dict]:
        if not css_dict:
            return None

        matching_css_props: List[_CSSPropsWithIndex] = []

        for c in element_classes:
            css_props = css_dict.get(c, None)
            if css_props is not None:
                matching_css_props.append(css_props)

        if matching_css_props:
            matching_css_props.sort(key=lambda x: x.index)

        id_css_props = css_dict.get(element_id, None)
        if id_css_props is not None:
            matching_css_props.append(id_css_props)

        if not matching_css_props:
            return None

        result: Dict[str, str] = {}
        for css_props in matching_css_props:
            result.update(css_props.props)

        return result

    @staticmethod
    def __create_css_dict(html_props: dict) -> Dict[str, _CSSPropsWithIndex]:
        cellstyle = html_props.get("cellstyle", None)
        css_dict: Dict[str, _CSSPropsWithIndex] = {}
        if cellstyle is not None:
            for index, entry in enumerate(cellstyle):
                props = entry['props']
                if not props:
                    continue
                css_props = _CSSPropsWithIndex({p[0]: p[1].lstrip(' ') for p in props}, index)
                for s in entry.get('selectors', []):
                    css_dict[s] = css_props
        return css_dict

from typing import Optional
from dataclasses import dataclass
import json


@dataclass(frozen=True)
class TableFrameValidationResult:
    actual: str
    expected: str
    is_equal: bool


class TableFrameValidator:
    def __init__(self, styler_context: PatchedStylerContext, generator: Optional[TableFrameGenerator] = None):
        self.__styler_context: PatchedStylerContext = styler_context
        self.__generator: TableFrameGenerator = TableFrameGenerator(styler_context) if generator is None else generator

    def validate(self,
                 rows_per_chunk: int,
                 cols_per_chunk: int,
                 region: Region = None,
                 ) -> TableFrameValidationResult:
        if region is None:
            region = self.__styler_context.get_region_of_visible_frame()
        else:
            region = self.__styler_context.compute_visible_intersection(region)

        if region.is_empty():
            return TableFrameValidationResult('', '', True)
        combined_table = self.__generator.generate_by_combining_chunks(rows_per_chunk, cols_per_chunk, region)
        expected_table = self.__generator.generate(region)
        combined_json = self.__jsonify_table(combined_table)
        expected_json = self.__jsonify_table(expected_table)
        return TableFrameValidationResult(combined_json, expected_json, combined_json == expected_json)

    @staticmethod
    def __jsonify_table(table: TableFrame) -> str:
        return json.dumps(table, indent=2, cls=CustomJSONEncoder)

from dataclasses import dataclass
from enum import Enum
from typing import List, Tuple, Optional
from abc import ABC, abstractmethod


@dataclass(frozen=True)
class StyleFunctionValidationProblem:
    index: int
    reason: str
    message: str = ""


class ValidationStrategyType(Enum):
    FAST = "fast"
    PRECISION = "precision"


class _AbstractValidationStrategy(ABC):
    def __init__(self, strategy_type: ValidationStrategyType):
        self._strategy_type: ValidationStrategyType = strategy_type

    @property
    def strategy_type(self):
        return self._strategy_type

    @abstractmethod
    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:
        pass

    @staticmethod
    def _ceiling_division(n, d):
        return -(n // -d)


class _PrecisionValidationStrategy(_AbstractValidationStrategy):
    def __init__(self):
        super().__init__(ValidationStrategyType.PRECISION)

    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:
        cols_per_chunk = max(1, self._ceiling_division(rows_in_region, 2))
        rows_per_chunk = max(1, self._ceiling_division(columns_in_region, 2))
        return rows_per_chunk, cols_per_chunk


class _FastValidationStrategy(_AbstractValidationStrategy):
    def __init__(self):
        super().__init__(ValidationStrategyType.FAST)
        self.__split_vertical = True

    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:
        rows_per_chunk = rows_in_region
        cols_per_chunk = columns_in_region

        if self.__split_vertical:
            cols_per_chunk = max(1, self._ceiling_division(cols_per_chunk, 2))
        else:
            rows_per_chunk = max(1, self._ceiling_division(rows_per_chunk, 2))

        self.__split_vertical = not self.__split_vertical
        return rows_per_chunk, cols_per_chunk


class StyleFunctionsValidator:
    def __init__(self, styler_context: PatchedStylerContext, strategy_type: Optional[ValidationStrategyType] = None):
        self.__styler_context: PatchedStylerContext = styler_context
        self.__apply_todos_count: int = self.__count_apply_todos(styler_context.get_styler_todos())
        self.__validation_strategy: _AbstractValidationStrategy = self.__create_validation_strategy(strategy_type)

    def validate(self, region: Region = None) -> List[StyleFunctionValidationProblem]:
        if self.__apply_todos_count == 0:
            return []

        if region is None:
            region = self.__styler_context.get_region_of_visible_frame()

        rows_per_chunk, cols_per_chunk = self.__validation_strategy.get_chunk_size(region.rows, region.cols)

        if self.__apply_todos_count == 1:
            return self.__validate_todos_separately(region, rows_per_chunk, cols_per_chunk)

        try:
            validator = TableFrameValidator(self.__styler_context)
            if validator.validate(rows_per_chunk, cols_per_chunk, region).is_equal:
                return []
        except Exception:
            pass

        return self.__validate_todos_separately(region, rows_per_chunk, cols_per_chunk)

    def __validate_todos_separately(self,
                                    region: Region,
                                    rows_per_chunk: int,
                                    cols_per_chunk: int,
                                    ) -> List[StyleFunctionValidationProblem]:
        validation_result = []

        ctx = self.__styler_context
        for i, todo in enumerate(ctx.get_styler_todos()):
            try:
                if todo.is_applymap():
                    continue
                validator = TableFrameValidator(ctx, TableFrameGenerator(ctx, lambda x: x is todo))
                result = validator.validate(rows_per_chunk, cols_per_chunk, region)
                if not result.is_equal:
                    validation_result.append(StyleFunctionValidationProblem(i, "NOT_EQUAL"))
            except Exception as e:
                validation_result.append(StyleFunctionValidationProblem(i, "EXCEPTION", str(e)))

        return validation_result

    @staticmethod
    def __count_apply_todos(todos: List[StylerTodo]) -> int:
        return 0 if not todos else len([not t.is_applymap() for t in todos])

    @staticmethod
    def __create_validation_strategy(strategy_type: Optional[ValidationStrategyType] = None):
        if strategy_type is ValidationStrategyType.PRECISION:
            return _PrecisionValidationStrategy()
        else:
            return _FastValidationStrategy()

import json
from dataclasses import dataclass
from typing import Optional, List, Any
import numpy as np


@dataclass(frozen=True)
class TableStructure:
    org_rows_count: int
    org_columns_count: int
    rows_count: int
    columns_count: int
    fingerprint: str


@dataclass(frozen=True)
class StyleFunctionDetails:
    index: int
    qname: str
    resolved_name: str
    axis: str
    is_chunk_parent_requested: bool
    is_apply: bool
    is_pandas_builtin: bool
    is_supported: bool


class PatchedStyler:
    def __init__(self, context: PatchedStylerContext, fingerprint: str):
        self.__context: PatchedStylerContext = context
        self.__fingerprint: str = fingerprint

    def internal_get_context(self) -> PatchedStylerContext:
        return self.__context

    def get_org_indices_of_visible_columns(self, part_start: int, max_columns: int) -> str:
        part = self.__context.get_org_indices_of_visible_columns(part_start, max_columns)
        return np.array2string(part, separator=', ').replace('\n', '')

    @staticmethod
    def to_json(data: Any) -> str:
        return json.dumps(data, cls=CustomJSONEncoder)

    def validate_style_functions(self,
                                 first_row: int,
                                 first_col: int,
                                 rows: int,
                                 cols: int,
                                 validation_strategy: Optional[ValidationStrategyType] = None,
                                 ) -> List[StyleFunctionValidationProblem]:
        return StyleFunctionsValidator(self.__context, validation_strategy)\
            .validate(Region(first_row, first_col, rows, cols))

    def set_sort_criteria(self,
                          by_column_index: Optional[List[int]] = None,
                          ascending: Optional[List[bool]] = None,
                          ):
        self.__context.set_sort_criteria(by_column_index, ascending)

    def compute_chunk_table_frame(self,
                                  first_row: int,
                                  first_col: int,
                                  rows: int,
                                  cols: int,
                                  exclude_row_header: bool = False,
                                  exclude_col_header: bool = False,
                                  ) -> TableFrame:
        return TableFrameGenerator(self.__context).generate(
            region=Region(first_row, first_col, rows, cols),
            exclude_row_header=exclude_row_header,
            exclude_col_header=exclude_col_header,
        )

    def get_table_structure(self) -> TableStructure:
        visible_frame = self.__context.get_visible_frame()
        styler = self.__context.get_styler()
        org_rows_count = len(styler.data.index)
        org_columns_count = len(styler.data.columns)
        rows_count = len(visible_frame.index)
        columns_count = len(visible_frame.columns)
        if rows_count == 0 or columns_count == 0:
            rows_count = columns_count = 0
        return TableStructure(
            org_rows_count=org_rows_count,
            org_columns_count=org_columns_count,
            rows_count=rows_count,
            columns_count=columns_count,
            fingerprint=self.__fingerprint
        )

    def get_style_function_details(self) -> List[StyleFunctionDetails]:
        result = []

        for i, todo in enumerate(self.__context.get_styler_todos()):
            result.append(StyleFunctionDetails(
                index=i,
                qname=StyleFunctionNameResolver.get_style_func_qname(todo),
                resolved_name=StyleFunctionNameResolver.resolve_style_func_name(todo),
                axis='' if todo.is_applymap() else str(todo.apply_args.axis),
                is_pandas_builtin=todo.is_pandas_style_func(),
                is_supported=TodosPatcher.is_style_function_supported(todo),
                is_apply=not todo.is_applymap(),
                is_chunk_parent_requested=todo.should_provide_chunk_parent(),
            ))

        return result

import json
import inspect
from dataclasses import dataclass
from typing import Union, Optional
from pandas import DataFrame
from pandas.io.formats.style import Styler


@dataclass(frozen=True)
class CreatePatchedStylerConfig:
    data_source_to_frame_hint: Optional[str] = None
    previous_fingerprint: Optional[str] = None
    filter_eval_expr: Optional[str] = None
    filter_eval_expr_provide_frame: Optional[bool] = None


@dataclass(frozen=True)
class CreatePatchedStylerFailure:
    error_kind: str
    info: str

    def to_json(self) -> str:
        return json.dumps(self, cls=CustomJSONEncoder)


class StyledDataFrameViewerBridge:
    @staticmethod
    def create_patched_styler(
            data_source: Union[DataFrame, Styler, dict],
            create_config: CreatePatchedStylerConfig = None,
    ) -> Union[PatchedStyler, str]:
        config = create_config if create_config is not None else CreatePatchedStylerConfig()
        ds_frame = None
        ds_frame_style = None
        if isinstance(data_source, dict):
            if config.data_source_to_frame_hint == "DictKeysAsRows":
                ds_frame = DataFrame.from_dict(data_source, orient='index')
            else:
                ds_frame = DataFrame.from_dict(data_source, orient='columns')
            ds_frame_style = ds_frame.style
        elif isinstance(data_source, DataFrame):
            ds_frame = data_source
            ds_frame_style = data_source.style
        elif isinstance(data_source, Styler):
            ds_frame = data_source.data
            ds_frame_style = data_source
        else:
            return CreatePatchedStylerFailure(error_kind="UNSUPPORTED_DATA_SOURCE_TYPE",
                                              info=type(data_source)).to_json()

        pre_fingerprint = config.previous_fingerprint
        cur_fingerprint = create_fingerprint(ds_frame, data_source)
        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:
            return CreatePatchedStylerFailure(error_kind="INVALID_FINGERPRINT", info=cur_fingerprint).to_json()

        filter_frame = None
        filter_eval_expr = config.filter_eval_expr
        if filter_eval_expr is not None and filter_eval_expr != "":
            try:
                parent_frame = inspect.currentframe().f_back
                updated_locals = {**parent_frame.f_locals}
                if config.filter_eval_expr_provide_frame:
                    updated_locals["_df"] = ds_frame
                filter_frame = eval(filter_eval_expr, parent_frame.f_globals, updated_locals)
            except Exception as e:
                return CreatePatchedStylerFailure(error_kind="FILTER_FRAME_EVAL_FAILED", info=repr(e)).to_json()

            if not isinstance(filter_frame, DataFrame):
                return CreatePatchedStylerFailure(error_kind="FILTER_FRAME_OF_WRONG_TYPE",
                                                  info=type(filter_frame)).to_json()

        return PatchedStyler(
            PatchedStylerContext(ds_frame_style, FilterCriteria.from_frame(filter_frame)),
            fingerprint=cur_fingerprint,
        )
