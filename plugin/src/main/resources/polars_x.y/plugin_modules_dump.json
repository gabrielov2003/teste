{
    "cms_rendner_sdfv": {
        "polars": {
            "create_fingerprint": "from hashlib import blake2b\nfrom typing import Any\n\nfrom polars import DataFrame\n\n\ndef create_fingerprint(frame: DataFrame, org_data_source: Any = None) -> str:\n    fingerprint_input = [\n        id(org_data_source if org_data_source is not None else frame),\n        frame.shape,\n        frame.columns[:60],\n        frame.dtypes[:60]\n    ]\n    return blake2b('-'.join(str(x) for x in fingerprint_input).encode(), digest_size=16).hexdigest()\n",
            "frame_context": "from typing import List, Optional\n\nfrom polars import DataFrame\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator, AbstractTableSourceContext\nfrom cms_rendner_sdfv.base.types import SortCriteria, TableStructure\nfrom cms_rendner_sdfv.polars.visible_frame import VisibleFrame\n\n\nclass FrameContext(AbstractTableSourceContext):\n    def __init__(self, source_frame: DataFrame):\n        self._source_frame = source_frame\n        self._sort_criteria: SortCriteria = SortCriteria()\n        self._visible_frame: VisibleFrame = self._recompute_visible_frame()\n\n    @property\n    def visible_frame(self) -> VisibleFrame:\n        return self._visible_frame\n\n    def set_sort_criteria(self, sort_by_column_index: Optional[List[int]], sort_ascending: Optional[List[bool]]):\n        new_sort_criteria = SortCriteria(sort_by_column_index, sort_ascending)\n        if new_sort_criteria != self._sort_criteria:\n            self._sort_criteria = new_sort_criteria\n            self._visible_frame = self._recompute_visible_frame()\n\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        rows_count, columns_count = self._visible_frame.region.frame_shape\n        org_rows_count, org_cols_count = self._source_frame.shape\n        if rows_count == 0 or columns_count == 0:\n            rows_count = columns_count = 0\n        return TableStructure(\n            org_rows_count=org_rows_count,\n            org_columns_count=org_cols_count,\n            rows_count=rows_count,\n            columns_count=columns_count,\n            fingerprint=fingerprint,\n        )\n\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        from cms_rendner_sdfv.polars.table_frame_generator import TableFrameGenerator\n        return TableFrameGenerator(self._visible_frame)\n\n    def _recompute_visible_frame(self) -> VisibleFrame:\n        row_idx = None\n        if not self._sort_criteria.is_empty():\n            col_names = self._source_frame.columns\n\n            row_idx_col_name: str = \"cms_render_sdfv__row_nr\"\n\n            if hasattr(self._source_frame, 'with_row_index'):\n                frame_with_index = self._source_frame.with_row_index(row_idx_col_name)\n            else:\n                frame_with_index = self._source_frame.with_row_count(row_idx_col_name)\n\n            by_names = [col_names[i] for i in self._sort_criteria.by_column]\n            row_idx = frame_with_index \\\n                .sort(by_names, descending=[not asc for asc in self._sort_criteria.ascending]) \\\n                .get_column(row_idx_col_name)\n\n        return VisibleFrame(self._source_frame, row_idx)\n",
            "table_frame_generator": "import os\nfrom typing import List\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableFrameGenerator\nfrom cms_rendner_sdfv.base.types import Region, TableFrame, TableFrameCell, TableFrameColumn\nfrom cms_rendner_sdfv.polars.visible_frame import VisibleFrame, Chunk\n\n\nclass TableFrameGenerator(AbstractTableFrameGenerator):\n    def __init__(self, visible_frame: VisibleFrame):\n        super().__init__(visible_frame)\n\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        chunk = self._visible_frame.get_chunk(region)\n\n        columns = [] if exclude_col_header else self._extract_columns(chunk)\n        cells = self._extract_cells(chunk)\n\n        return TableFrame(\n            index_labels=None,\n            columns=columns,\n            legend=None,\n            cells=cells,\n        )\n\n    def _extract_columns(self, chunk: Chunk) -> List[TableFrameColumn]:\n        result: List[TableFrameColumn] = []\n\n        for col_offset in range(chunk.region.cols):\n            series = chunk.series_at(col_offset)\n            result.append(\n                TableFrameColumn(\n                    dtype=str(series.dtype),\n                    labels=[series.name],\n                    describe=None if self._exclude_column_describe else chunk.describe(series)\n                )\n            )\n\n        return result\n\n    @staticmethod\n    def _extract_cells(chunk: Chunk) -> List[List[TableFrameCell]]:\n        result: List[List[TableFrameCell]] = []\n\n        if chunk.region.is_empty():\n            return result\n\n        str_lengths = int(os.environ.get(\"POLARS_FMT_STR_LEN\", \"42\"))\n\n        for col_offset in range(chunk.region.cols):\n            series = chunk.series_at(col_offset)\n            is_string = isinstance(series.dtype, pl.Utf8)\n            should_create_row = not result\n            for ri, sri in enumerate(chunk.row_idx_iter()):\n                if is_string:\n                    v = series._s.get_fmt(sri, str_lengths + 2)\n                    if v[-1] == '\"':\n                        v = v[1:-1]\n                    else:\n                        v = v[1:-2] + v[-1]\n                else:\n                    v = series._s.get_fmt(sri, str_lengths)\n\n                if should_create_row:\n                    result.append([TableFrameCell(v)])\n                else:\n                    result[ri].append(TableFrameCell(v))\n\n        return result\n",
            "table_source": "from cms_rendner_sdfv.base.table_source import AbstractTableSource\nfrom cms_rendner_sdfv.base.types import TableSourceKind\nfrom cms_rendner_sdfv.polars.frame_context import FrameContext\n\n\nclass TableSource(AbstractTableSource):\n    def __init__(self, context: FrameContext, fingerprint: str):\n        super().__init__(TableSourceKind.TABLE_SOURCE, context, fingerprint)\n",
            "table_source_factory": "from typing import Any, Union\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.table_source import AbstractTableSource, AbstractTableSourceFactory\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure\nfrom cms_rendner_sdfv.polars.create_fingerprint import create_fingerprint\nfrom cms_rendner_sdfv.polars.frame_context import FrameContext\nfrom cms_rendner_sdfv.polars.table_source import TableSource\n\n\nclass TableSourceFactory(AbstractTableSourceFactory):\n\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        ds_frame = None\n        if isinstance(data_source, dict):\n            ds_frame = pl.from_dict(data_source)\n        elif isinstance(data_source, pl.DataFrame):\n            ds_frame = data_source\n        else:\n            return CreateTableSourceFailure(error_kind=\"UNSUPPORTED_DATA_SOURCE_TYPE\", info=str(type(data_source)))\n\n        pre_fingerprint = config.previous_fingerprint\n        cur_fingerprint = create_fingerprint(ds_frame, data_source)\n        if pre_fingerprint is not None and pre_fingerprint != cur_fingerprint:\n            return CreateTableSourceFailure(error_kind=\"INVALID_FINGERPRINT\", info=cur_fingerprint)\n\n        return TableSource(FrameContext(ds_frame), fingerprint=cur_fingerprint)\n",
            "visible_frame": "from typing import Union, Dict, Iterator\n\nimport polars as pl\n\nfrom cms_rendner_sdfv.base.table_source import AbstractVisibleFrame\nfrom cms_rendner_sdfv.base.types import Region\n\n\nclass Chunk:\n    def __init__(self, frame: 'VisibleFrame', region: Region):\n        self._frame = frame\n        self._region = region\n\n    @property\n    def region(self) -> Region:\n        return self._region\n\n    def series_at(self, offset: int) -> pl.Series:\n        return self._frame.series_at(self._region.first_col + offset)\n\n    @staticmethod\n    def describe(s: pl.Series) -> Dict[str, str]:\n        def truncate(v) -> str:\n            vs = str(v)\n            return vs if len(vs) <= 120 else vs[:120] + '\u2026'\n        try:\n            df = s.describe()\n            keys = df.get_column(df.columns[0]).to_list()\n            values = [truncate(v) for v in df.get_column(df.columns[1]).to_list()]\n            return dict(zip(keys, values))\n        except TypeError as e:\n            return {'error': str(e)}\n\n    def row_idx_iter(self) -> Iterator[int]:\n        return self._frame.row_idx_iter(self._region)\n\n\nclass VisibleFrame(AbstractVisibleFrame):\n    def __init__(self, source_frame: pl.DataFrame, row_idx: Union[None, pl.Series]):\n        self._source_frame = source_frame\n        self._column_names = source_frame.columns\n        self._row_idx = row_idx\n        self._region = Region.with_frame_shape(source_frame.shape)\n\n    @property\n    def region(self) -> Region:\n        return self._region\n\n    def row_idx_iter(self, region: Region = None) -> Iterator[int]:\n        region = self._sanitized_region(region)\n        i = 0\n        while i < region.rows:\n            if self._row_idx is None:\n                yield i + region.first_row\n            else:\n                yield self._row_idx[i + region.first_row]\n            i += 1\n\n    def series_at(self, offset: int) -> pl.Series:\n        name = self._column_names[self.region.first_col + offset]\n        return self._source_frame.get_column(name)\n\n    def get_chunk(self, region: Region = None) -> Chunk:\n        return Chunk(self, self._sanitized_region(region))\n\n    def _sanitized_region(self, region: Region = None) -> Region:\n        return self._region if region is None else self.region.get_bounded_region(region)\n"
        }
    }
}