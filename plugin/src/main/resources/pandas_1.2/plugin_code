
from typing import Tuple, Callable, Optional, Union
from pandas._typing import Axis


class ApplyMapArgs:

    def __init__(self, style_func: Callable, subset: Optional[any]):
        self._style_func: Callable = style_func
        self._subset: Optional[any] = subset

    @property
    def style_func(self):
        return self._style_func

    @property
    def subset(self):
        return self._subset

    @classmethod
    def from_tuple(cls, args: Tuple[Callable, Optional[any]]):
        return cls(args[0], args[1])

    def copy_with(self, style_func: Optional[Callable] = None, subset: Optional[any] = None):
        return ApplyMapArgs(
            self.style_func if style_func is None else style_func,
            self.subset if subset is None else subset,
        )

    def to_tuple(self) -> Tuple[Callable, Optional[any]]:
        return self.style_func, self.subset


class ApplyArgs:

    def __init__(self, style_func: Callable, axis: Optional[Axis], subset: Optional[any]):
        self._style_func: Callable = style_func
        self._axis: Optional[Axis] = axis
        self._subset: Optional[any] = subset

    @property
    def style_func(self):
        return self._style_func

    @property
    def axis(self):
        return self._axis

    @property
    def subset(self):
        return self._subset

    @classmethod
    def from_tuple(cls, args: Tuple[Callable, Optional[Axis], Optional[any]]):
        return cls(args[0], args[1], args[2])

    def copy_with(self, style_func: Optional[Callable] = None, subset: Optional[any] = None):
        return ApplyArgs(
            self.style_func if style_func is None else style_func,
            self.axis,
            self.subset if subset is None else subset,
        )

    def to_tuple(self) -> Tuple[Callable, Optional[Axis], Optional[any]]:
        return self.style_func, self.axis, self.subset


class StylerTodo:
    def __init__(self, apply_func: Callable, apply_args: Union[ApplyArgs, ApplyMapArgs], style_func_kwargs: dict):
        self._apply_func: Callable = apply_func
        self._apply_args: Union[ApplyArgs, ApplyMapArgs] = apply_args
        self._style_func_kwargs: dict = style_func_kwargs

    @property
    def apply_func(self):
        return self._apply_func

    @property
    def apply_args(self):
        return self._apply_args

    @property
    def style_func_kwargs(self):
        return self._style_func_kwargs

    @classmethod
    def from_tuple(cls, todo: Tuple[Callable, tuple, dict]):
        return cls(todo[0], cls._to_apply_args(todo), todo[2])

    def copy_with(self,
                  apply_args_subset: Optional[any] = None,
                  style_func: Optional[Callable] = None,
                  style_func_kwargs: Optional[dict] = None,
                  ):
        return StylerTodo(
            self.apply_func,
            self.apply_args.copy_with(style_func=style_func, subset=apply_args_subset),
            dict(**self.style_func_kwargs) if style_func_kwargs is None else style_func_kwargs,
        )

    @staticmethod
    def _to_apply_args(todo: Tuple[Callable, tuple, dict]):
        if getattr(todo[0], '__qualname__', '').startswith('Styler.applymap'):
            return ApplyMapArgs.from_tuple(todo[1])
        else:
            return ApplyArgs.from_tuple(todo[1])

    def is_applymap_call(self) -> bool:
        return isinstance(self.apply_args, ApplyMapArgs)

    def is_apply_call(self) -> bool:
        return not self.is_applymap_call()

    def to_tuple(self) -> Tuple[Callable, tuple, dict]:
        return self.apply_func, self.apply_args.to_tuple(), self.style_func_kwargs

from abc import ABC, abstractmethod
from typing import Optional

from pandas import DataFrame
from pandas.core.indexing import non_reducing_slice


class TodoPatcher(ABC):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        self._todo: StylerTodo = todo
        self._subset_data: DataFrame = self._get_subset_data(df, todo.apply_args.subset)

    @abstractmethod
    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        pass

    def _calculate_chunk_subset(self, chunk: DataFrame) -> any:
        index_intersection = chunk.index.intersection(self._subset_data.index)
        column_intersection = chunk.columns.intersection(self._subset_data.columns)
        return index_intersection, column_intersection

    @staticmethod
    def _get_subset_data(df: DataFrame, subset: Optional[any]) -> DataFrame:
        subset = slice(None) if subset is None else subset
        subset = non_reducing_slice(subset)
        return df.loc[subset]

from typing import Optional
from pandas import DataFrame


class ApplyMapPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        super().__init__(df, todo)

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        return self._todo.copy_with(
            apply_args_subset=self._calculate_chunk_subset(chunk),
        )

import inspect
from typing import Optional, Union

from pandas import DataFrame, Series


class ApplyPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        super().__init__(df, todo)

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        if self._should_provide_chunk_parent():
            return self._todo.copy_with(
                apply_args_subset=self._calculate_chunk_subset(chunk),
                style_func=ChunkParentProvider(
                    self._styling_func,
                    self._todo.apply_args.axis,
                    self._subset_data,
                )
            )
        else:
            return self._todo.copy_with(
                apply_args_subset=self._calculate_chunk_subset(chunk),
                style_func=self._styling_func,
            )

    def _styling_func(self,
                      chunk_or_series_from_chunk: Union[DataFrame, Series],
                      **kwargs,
                      ):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        return self._todo.apply_args.style_func(chunk_or_series_from_chunk, **kwargs)

    def _should_provide_chunk_parent(self):
        sig = inspect.signature(self._todo.apply_args.style_func)
        for param in sig.parameters.values():
            if param.name == "chunk_parent" or param.kind == inspect.Parameter.VAR_KEYWORD:
                return True
        return False

from typing import Optional, Union

import numpy as np
from pandas import DataFrame, Series


class BackgroundGradientPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        super().__init__(df, todo)

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        return self._todo.copy_with(
            apply_args_subset=self._calculate_chunk_subset(chunk),
            style_func=ChunkParentProvider(
                self._styling_func,
                self._todo.apply_args.axis,
                self._subset_data,
            )
        )

    def _styling_func(self,
                      chunk_or_series_from_chunk: Union[DataFrame, Series],
                      chunk_parent: Union[DataFrame, Series],
                      **kwargs,
                      ):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        vmin = kwargs.get("vmin", None)
        vmax = kwargs.get("vmax", None)

        if vmin is None or vmax is None:
            n = chunk_parent.to_numpy()
            if vmin is None:
                vmin = np.nanmin(n)
            if vmax is None:
                vmax = np.nanmax(n)

        return self._todo.apply_args.style_func(
            chunk_or_series_from_chunk,
            **dict(kwargs, vmin=vmin, vmax=vmax),
        )

from typing import Callable, Optional, Union

from pandas import DataFrame, Series
from pandas._typing import Axis


class ChunkParentProvider:
    def __init__(self, style_func: Callable, axis: Optional[Axis], subset_data: DataFrame):
        self._style_func = style_func
        self._axis = axis
        self._subset_data = subset_data

    def __call__(self, chunk_or_series_from_chunk: Union[DataFrame, Series], *args, **kwargs):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        kwargs['chunk_parent'] = self._get_parent(chunk_or_series_from_chunk)
        return self._style_func(chunk_or_series_from_chunk, *args, **kwargs)

    def _get_parent(self, chunk_or_series_from_chunk: Union[DataFrame, Series]):
        if self._axis == 0 or self._axis == "index":
            return self._subset_data[chunk_or_series_from_chunk.name]
        elif self._axis == 1 or self._axis == "columns":
            return self._subset_data.loc[chunk_or_series_from_chunk.name]
        else:
            return self._subset_data

import numpy as np
from typing import Optional, Union
from pandas import DataFrame, Series


class HighlightExtremaPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        super().__init__(df, todo)
        self._max: bool = todo.style_func_kwargs.get('max_', False)
        self._attribute: str = f"background-color: {todo.style_func_kwargs.get('color', 'yellow')}"

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        return self._todo.copy_with(
            apply_args_subset=self._calculate_chunk_subset(chunk),
            style_func_kwargs={},
            style_func=ChunkParentProvider(
                self._styling_func,
                self._todo.apply_args.axis,
                self._subset_data,
            )
        )

    def _styling_func(self,
                      chunk_or_series_from_chunk: Union[DataFrame, Series],
                      chunk_parent: Union[DataFrame, Series],
                      ):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        if self._max:
            extrema = chunk_or_series_from_chunk == np.nanmax(chunk_parent.to_numpy())
        else:
            extrema = chunk_or_series_from_chunk == np.nanmin(chunk_parent.to_numpy())

        if chunk_or_series_from_chunk.ndim == 1:
            return [self._attribute if v else "" for v in extrema]
        else:
            return DataFrame(
                np.where(extrema, self._attribute, ""),
                index=chunk_or_series_from_chunk.index,
                columns=chunk_or_series_from_chunk.columns
            )

class TableStructure:
    def __init__(self,
                 rows_count: int,
                 columns_count: int,
                 row_levels_count: int,
                 column_levels_count: int,
                 hide_row_header: bool):
        self.rows_count = rows_count
        self.columns_count = columns_count
        self.row_levels_count = row_levels_count
        self.column_levels_count = column_levels_count
        self.hide_row_header = hide_row_header
        self.hide_column_header = False

import inspect
from functools import partial
from typing import Callable, List, Tuple, Optional

from pandas import DataFrame
from pandas.io.formats.style import Styler


class TodosPatcher:

    def patch_todos_for_chunk(self, source: Styler, chunk: DataFrame) -> List[Tuple[Callable, tuple, dict]]:
        result: List[Tuple[Callable, tuple, dict]] = []

        for t in source._todo:
            todo = StylerTodo.from_tuple(t)

            if self.__is_builtin_style(todo.apply_args.style_func):
                patcher = self.__get_patcher_for_builtin_style(source.data, todo)
            else:
                if todo.is_applymap_call():
                    patcher = ApplyMapPatcher(source.data, todo)
                else:
                    patcher = ApplyPatcher(source.data, todo)

            if patcher is not None:
                result.append(patcher.create_patched_todo(chunk).to_tuple())

        return result

    def __get_patcher_for_builtin_style(self, df: DataFrame, todo: StylerTodo) -> Optional[TodoPatcher]:
        style_func_qname = self.__get_qname(todo.apply_args.style_func)
        if self.__is_builtin_background_gradient(style_func_qname):
            return BackgroundGradientPatcher(df, todo)
        elif self.__is_builtin_highlight_extrema(style_func_qname):
            return HighlightExtremaPatcher(df, todo)
        elif self.__is_builtin_highlight_null(style_func_qname):
            return ApplyMapPatcher(df, todo)
        elif self.__is_builtin_set_properties(style_func_qname):
            return ApplyMapPatcher(df, todo)
        return None

    @staticmethod
    def __get_qname(func: Callable) -> str:
        if isinstance(func, partial):
            func = func.func
        return getattr(func, '__qualname__', '')

    @staticmethod
    def __is_builtin_style(style_func_qname: Callable) -> bool:
        if isinstance(style_func_qname, partial):
            style_func_qname = style_func_qname.func
        inspect_result = inspect.getmodule(style_func_qname)
        return False if inspect_result is None else inspect.getmodule(
            style_func_qname).__name__ == 'pandas.io.formats.style'

    @staticmethod
    def __is_builtin_background_gradient(style_func_qname: str) -> bool:
        return style_func_qname == 'Styler._background_gradient'

    @staticmethod
    def __is_builtin_highlight_extrema(style_func_qname: str) -> bool:
        return style_func_qname.startswith('Styler._highlight_extrema')

    @staticmethod
    def __is_builtin_highlight_null(style_func_qname: str) -> bool:
        return style_func_qname.startswith('Styler._highlight_null')

    @staticmethod
    def __is_builtin_set_properties(style_func_qname: str) -> bool:
        return style_func_qname.startswith('Styler.set_properties')

import numpy as np
from pandas import DataFrame
from pandas.io.formats.style import Styler
from typing import List, Tuple, Callable
from collections.abc import Mapping
from abc import ABC, abstractmethod


class _IndexTranslator(ABC):
    @abstractmethod
    def translate(self, index):
        pass


class _SequenceIndexTranslator(_IndexTranslator):
    def __init__(self, seq):
        super().__init__()
        self.__seq = seq

    def translate(self, index):
        return self.__seq[index]


class _OffsetIndexTranslator(_IndexTranslator):
    def __init__(self, offset: int):
        super().__init__()
        self.__offset = offset

    def translate(self, index):
        return index + self.__offset


class _TranslateKeysDict(Mapping):

    def __init__(self, org_dict: dict, translate_key: Callable):
        self._org_dict = org_dict
        self._translate_key = translate_key

    def get(self, key, default=None):
        t_key = self._translate_key(key)
        if t_key not in self._org_dict:
            return default
        return self._org_dict.get(t_key)

    def __contains__(self, key):
        return self._translate_key(key) in self._org_dict

    def __getitem__(self, key):
        return self._org_dict[self._translate_key(key)]

    def values(self):
        return super().values()

    def __iter__(self):
        raise NotImplementedError

    def keys(self):
        raise NotImplementedError

    def items(self):
        raise NotImplementedError

    def __len__(self):
        return len(self._org_dict)


class _CSSRowColIndexAdjuster:

    def __init__(self, ri_translator: _IndexTranslator, ci_translator: _IndexTranslator):
        self.ri_translator = ri_translator
        self.ci_translator = ci_translator

    def adjust(self, d: dict):
        for head in d.get('head', []):
            for col in head:
                if 'id' in col:
                    col['id'] = '_'.join(self._adjust_indices(col['id'].split('_')))
                if 'class' in col:
                    col['class'] = ' '.join(self._adjust_indices(col['class'].strip().split(' ')))

        for row in d.get('body', []):
            for entry in row:
                if 'id' in entry:
                    entry['id'] = '_'.join(self._adjust_indices(entry['id'].split('_')))
                if 'class' in entry:
                    entry['class'] = ' '.join(self._adjust_indices(entry['class'].strip().split(' ')))

        for style in d.get('cellstyle', []):
            if 'selectors' in style:
                style['selectors'] = ['_'.join(self._adjust_indices(s.split('_'))) for s in style['selectors']]

    def _adjust_indices(self, indices: List[str]) -> List[str]:
        return [self._adjust_index(x) for x in indices]

    def _adjust_index(self, index: str) -> str:
        if index.startswith("row") and index[3:].isdigit():
            return f'row{self.ri_translator.translate(int(index[3:]))}'
        if index.startswith("col") and index[3:].isdigit():
            return f'col{self.ci_translator.translate(int(index[3:]))}'
        return index


class PatchedStyler:

    def __init__(self, styler: Styler):
        self.__styler: Styler = styler
        self.__visible_data: DataFrame = self.__get_visible_data(styler)

    def render_chunk(
            self,
            first_row: int,
            first_column: int,
            last_row: int,
            last_column: int,
            exclude_row_header: bool = False,
            exclude_column_header: bool = False
    ) -> str:
        chunk = self.__visible_data.iloc[first_row:last_row, first_column:last_column]

        patched_todos = TodosPatcher().patch_todos_for_chunk(self.__styler, chunk)

        computed_styler = self.__compute_styles(
            patched_todos=patched_todos,
            exclude_row_header=exclude_row_header,
            exclude_column_header=exclude_column_header,
        )
        html_props = self.__generate_html_props_for_chunk(
            chunk=chunk,
            first_row=first_row,
            first_column=first_column,
            computed_styler=computed_styler,
        )

        return self.__styler.template.render(
            **html_props,
            encoding="utf-8",
            sparse_columns=False,
            sparse_index=False,
            doctype_html=True,
        )

    def __compute_styles(self,
                         patched_todos: List[Tuple[Callable, tuple, dict]],
                         exclude_row_header: bool = False,
                         exclude_column_header: bool = False,
                         ) -> Styler:
        copy = self.__styler.data.style
        self.__copy_styler_state(source=self.__styler, target=copy)

        copy._todo = patched_todos

        if exclude_row_header:
            copy.hide_index()

        copy._compute()
        return copy

    def __generate_html_props_for_chunk(self,
                                        chunk: DataFrame,
                                        first_row: int,
                                        first_column: int,
                                        computed_styler: Styler,
                                        ):
        rit = _OffsetIndexTranslator(first_row)
        if len(self.__styler.hidden_columns) == 0:
            cit = _OffsetIndexTranslator(first_column)
        else:
            cit = _SequenceIndexTranslator(self.__styler.columns.get_indexer_for(chunk.columns))

        chunk_styler = chunk.style
        self.__copy_styler_state(source=computed_styler, target=chunk_styler)

        def translate_key(k):
            return rit.translate(k[0]), cit.translate(k[1])

        chunk_styler.ctx = _TranslateKeysDict(computed_styler.ctx, translate_key)
        chunk_styler._display_funcs = _TranslateKeysDict(computed_styler._display_funcs, translate_key)
        self._copy_over_cell_context(source=computed_styler, target=chunk_styler, ri_translator=rit, ci_translator=cit)

        result = chunk_styler._translate()
        trimmed = [x for x in result["cellstyle"] if any(any(y) for y in x["props"])]
        result["cellstyle"] = trimmed

        _CSSRowColIndexAdjuster(rit, cit).adjust(result)

        return result

    @staticmethod
    def _copy_over_cell_context(
            source: Styler,
            target: Styler,
            ri_translator: _IndexTranslator,
            ci_translator: _IndexTranslator,
    ):
        if source.cell_context is not None and "data" in source.cell_context:

            source_data = source.cell_context["data"]
            target_data = {}

            def translate_column_key(k):
                return ci_translator.translate(k)

            for source_row_key, source_row in source_data.items():
                if len(source_row) > 0:
                    target_data[source_row_key] = _TranslateKeysDict(source_row, translate_column_key)

            target.cell_context = {"data": _TranslateKeysDict(target_data, lambda k: ri_translator.translate(k))}

    def render_unpatched(self) -> str:
        self.__styler.uuid = ''
        self.__styler.uuid_len = 0
        self.__styler.cell_ids = False
        return self.__styler.render(
            encoding="utf-8",
            doctype_html=True,
            sparse_columns=False,
            sparse_index=False,
        )

    def get_table_structure(self) -> TableStructure:
        return TableStructure(
            rows_count=len(self.__visible_data.index),
            columns_count=len(self.__visible_data.columns),
            row_levels_count=self.__visible_data.index.nlevels,
            column_levels_count=self.__visible_data.columns.nlevels,
            hide_row_header=self.__styler.hidden_index,
        )

    @staticmethod
    def __get_visible_data(styler: Styler) -> DataFrame:
        if len(styler.hidden_columns) == 0:
            return styler.data
        else:
            visible_columns = np.delete(styler.columns.get_indexer_for(styler.columns), styler.hidden_columns)
            return styler.data.iloc[:, visible_columns]

    @staticmethod
    def __copy_styler_state(
            source: Styler,
            target: Styler,
    ):
        target.uuid = ''
        target.uuid_len = 0
        target.cell_ids = False

        target.table_styles = source.table_styles
        target.table_attributes = source.table_attributes
        target.hidden_index = source.hidden_index
        target.cell_context = source.cell_context
        target._display_funcs = source._display_funcs

from typing import Union

from pandas import DataFrame
from pandas.io.formats.style import Styler




class StyledDataFrameViewerBridge:
    patched_styler_refs = []

    @classmethod
    def create_patched_styler(cls, frame_or_styler: Union[DataFrame, Styler]) -> PatchedStyler:
        p = PatchedStyler(frame_or_styler.style) if isinstance(frame_or_styler, DataFrame) else PatchedStyler(
            frame_or_styler)
        cls.patched_styler_refs.append(p)
        return p

    @classmethod
    def delete_patched_styler(cls, patched_styler: PatchedStyler):
        cls.patched_styler_refs.remove(patched_styler)

    @classmethod
    def delete_all(cls):
        cls.patched_styler_refs.clear()

    @staticmethod
    def check() -> bool:
        return True
