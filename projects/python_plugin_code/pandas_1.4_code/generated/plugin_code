
import inspect
from dataclasses import dataclass
from functools import partial
from typing import Tuple, Callable, Optional, Union
from pandas._typing import Axis
from pandas.io.formats.style_render import Subset


@dataclass(frozen=True)
class ApplyMapArgs:
    style_func: Callable
    subset: Optional[Subset]

    @classmethod
    def from_tuple(cls, args: Tuple[Callable, Optional[Subset]]):
        return cls(args[0], args[1])

    @staticmethod
    def copy_with(style_func: Callable, subset: Optional[Subset]):
        return ApplyMapArgs(style_func, subset)

    def to_tuple(self) -> Tuple[Callable, Optional[Subset]]:
        return self.style_func, self.subset


@dataclass(frozen=True)
class ApplyArgs:
    style_func: Callable
    axis: Optional[Axis]
    subset: Optional[Subset]

    @classmethod
    def from_tuple(cls, args: Tuple[Callable, Optional[Axis], Optional[Subset]]):
        return cls(args[0], args[1], args[2])

    def copy_with(self, style_func: Callable, subset: Optional[Subset]):
        return ApplyArgs(style_func, self.axis, subset)

    def to_tuple(self) -> Tuple[Callable, Optional[Axis], Optional[Subset]]:
        return self.style_func, self.axis, self.subset


@dataclass(frozen=True)
class StylerTodo:
    apply_func: Callable
    apply_args: Union[ApplyArgs, ApplyMapArgs]
    style_func_kwargs: dict

    @classmethod
    def from_tuple(cls, todo: Tuple[Callable, tuple, dict]):
        return cls(todo[0], cls._to_apply_args(todo), todo[2])

    def builder(self):
        return StylerTodoBuilder(self)

    @staticmethod
    def _to_apply_args(todo: Tuple[Callable, tuple, dict]):
        if getattr(todo[0], '__qualname__', '').startswith('Styler.applymap'):
            return ApplyMapArgs.from_tuple(todo[1])
        else:
            return ApplyArgs.from_tuple(todo[1])

    def is_applymap_call(self) -> bool:
        return isinstance(self.apply_args, ApplyMapArgs)

    def is_apply_call(self) -> bool:
        return not self.is_applymap_call()

    def is_pandas_style_func(self) -> bool:
        func = self.apply_args.style_func
        if isinstance(func, partial):
            func = func.func
        inspect_result = inspect.getmodule(func)
        return False if inspect_result is None else inspect.getmodule(func).__name__ == 'pandas.io.formats.style'

    def should_provide_chunk_parent(self):
        sig = inspect.signature(self.apply_args.style_func)
        for param in sig.parameters.values():
            if param.name == "chunk_parent" or param.kind == inspect.Parameter.VAR_KEYWORD:
                return True
        return False

    def to_tuple(self) -> Tuple[Callable, tuple, dict]:
        return self.apply_func, self.apply_args.to_tuple(), self.style_func_kwargs


class StylerTodoBuilder:

    def __init__(self, source: StylerTodo):
        self.source: StylerTodo = source
        self.values: dict = {}

    def with_subset(self, subset: Optional[Subset]):
        self.values["subset"] = subset
        return self

    def with_style_func(self, style_func: Callable):
        self.values["style_func"] = style_func
        return self

    def with_style_func_kwargs(self, style_func_kwargs: dict):
        self.values["style_func_kwargs"] = style_func_kwargs
        return self

    def build(self) -> StylerTodo:
        return StylerTodo(
            self.source.apply_func,
            self.source.apply_args.copy_with(
                style_func=self.values.get("style_func", self.source.apply_args.style_func),
                subset=self.values.get("subset", self.source.apply_args.subset),
            ),
            self.values.get("style_func_kwargs", self.source.style_func_kwargs),
        )

from functools import partial


class StyleFunctionNameResolver:

    @staticmethod
    def get_style_func_qname(todo: StylerTodo) -> str:
        func = todo.apply_args.style_func
        if isinstance(func, partial):
            func = func.func
        return getattr(func, '__qualname__', '')

    @staticmethod
    def resolve_style_func_name(todo: StylerTodo) -> str:
        qname = StyleFunctionNameResolver.get_style_func_qname(todo)
        if todo.is_pandas_style_func():
            if StyleFunctionNameResolver.is_pandas_text_gradient(qname, todo):
                return "text_gradient"
            elif StyleFunctionNameResolver.is_pandas_background_gradient(qname):
                return "background_gradient"
            elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):
                return "highlight_max"
            elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):
                return "highlight_min"
            elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):
                return "highlight_null"
            elif StyleFunctionNameResolver.is_pandas_highlight_between(qname):
                return "highlight_between or highlight_quantile"
            elif StyleFunctionNameResolver.is_pandas_set_properties(qname):
                return "set_properties"
            else:
                return qname.rpartition('.')[2]
        else:
            return qname.rpartition('.')[2]

    @staticmethod
    def is_pandas_background_gradient(style_func_qname: str) -> bool:
        return style_func_qname == '_background_gradient'

    @staticmethod
    def is_pandas_text_gradient(style_func_qname: str, todo: StylerTodo) -> bool:
        return style_func_qname == '_background_gradient' \
               and todo.style_func_kwargs.get("text_only", False)

    @staticmethod
    def is_pandas_highlight_max(style_func_qname: str, todo: StylerTodo) -> bool:
        return style_func_qname == '_highlight_value' \
               and isinstance(todo.apply_args.style_func, partial) \
               and todo.apply_args.style_func.keywords.get('op', '') == 'max'

    @staticmethod
    def is_pandas_highlight_min(style_func_qname: str, todo: StylerTodo) -> bool:
        return style_func_qname == '_highlight_value' \
               and isinstance(todo.apply_args.style_func, partial) \
               and todo.apply_args.style_func.keywords.get('op', '') == 'min'

    @staticmethod
    def is_pandas_highlight_null(style_func_qname: str) -> bool:
        return style_func_qname.startswith('Styler.highlight_null')

    @staticmethod
    def is_pandas_highlight_between(style_func_qname: str) -> bool:
        return style_func_qname == '_highlight_between'

    @staticmethod
    def is_pandas_set_properties(style_func_qname: str) -> bool:
        return style_func_qname.startswith('Styler.set_properties')

from abc import ABC, abstractmethod
from typing import Optional

from pandas import DataFrame
from pandas.io.formats.style_render import Subset, non_reducing_slice


class TodoPatcher(ABC):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        self._todo: StylerTodo = todo
        self._subset_data: DataFrame = df if df.empty else self._get_subset_data(df, todo.apply_args.subset)

    @abstractmethod
    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        pass

    def _calculate_chunk_subset(self, chunk: DataFrame) -> Subset:
        index_intersection = chunk.index.intersection(self._subset_data.index)
        column_intersection = chunk.columns.intersection(self._subset_data.columns)
        return index_intersection, column_intersection

    @staticmethod
    def _get_subset_data(df: DataFrame, subset: Optional[Subset]) -> DataFrame:
        subset = slice(None) if subset is None else subset
        subset = non_reducing_slice(subset)
        return df.loc[subset]

from typing import Optional
from pandas import DataFrame


class ApplyMapPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        super().__init__(df, todo)

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        return self._todo.builder() \
            .with_subset(self._calculate_chunk_subset(chunk)) \
            .build()

from typing import Optional, Union

from pandas import DataFrame, Series


class ApplyPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        super().__init__(df, todo)

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        builder = self._todo.builder().with_subset(self._calculate_chunk_subset(chunk))
        if self._todo.should_provide_chunk_parent():
            builder.with_style_func(
                ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, self._subset_data),
            )
        else:
            builder.with_style_func(self._styling_func)
        return builder.build()

    def _styling_func(self, chunk_or_series_from_chunk: Union[DataFrame, Series], **kwargs):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk
        return self._todo.apply_args.style_func(chunk_or_series_from_chunk, **kwargs)

from typing import Optional, Union

import numpy as np
from pandas import DataFrame, Series
from pandas.io.formats.style import _validate_apply_axis_arg


class BackgroundGradientPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        super().__init__(df, todo)

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        return self._todo.builder() \
            .with_subset(self._calculate_chunk_subset(chunk)) \
            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, self._subset_data))\
            .build()

    def _styling_func(self,
                      chunk_or_series_from_chunk: Union[DataFrame, Series],
                      chunk_parent: Union[DataFrame, Series],
                      **kwargs,
                      ):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk


        vmin = kwargs.get("vmin", None)
        vmax = kwargs.get("vmax", None)
        gmap = kwargs.get("gmap", None)

        if gmap is None:
            gmap = chunk_parent.to_numpy(dtype=float)
        else:
            gmap = _validate_apply_axis_arg(gmap, "gmap", float, chunk_parent)

        if vmin is None or vmax is None:
            if vmin is None:
                vmin = np.nanmin(gmap)
            if vmax is None:
                vmax = np.nanmax(gmap)

        gmap = self._adjust_gmap_shape_to_chunk_shape(gmap, chunk_or_series_from_chunk, chunk_parent)

        return self._todo.apply_args.style_func(
            chunk_or_series_from_chunk,
            **dict(kwargs, vmin=vmin, vmax=vmax, gmap=gmap),
        )

    def _adjust_gmap_shape_to_chunk_shape(self,
                                          gmap: np.ndarray,
                                          chunk_or_series_from_chunk: Union[DataFrame, Series],
                                          chunk_parent: Union[DataFrame, Series],
                                          ) -> np.ndarray:
        if isinstance(chunk_or_series_from_chunk, Series):
            return gmap[chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)]
        elif isinstance(chunk_or_series_from_chunk, DataFrame) and self._todo.apply_args.axis is None:
            ri = chunk_parent.index.get_indexer_for(chunk_or_series_from_chunk.index)
            ci = chunk_parent.columns.get_indexer_for(chunk_or_series_from_chunk.columns)
            if isinstance(gmap, DataFrame):
                return gmap.iloc[(ri, ci)]
            elif isinstance(gmap, np.ndarray):
                return DataFrame(data=gmap, index=chunk_parent.index, columns=chunk_parent.columns).iloc[(ri, ci)]
        return gmap

from typing import Callable, Optional, Union

from pandas import DataFrame, Series
from pandas._typing import Axis


class ChunkParentProvider:
    def __init__(self, style_func: Callable, axis: Optional[Axis], subset_data: DataFrame):
        self._style_func = style_func
        self._axis = axis
        self._subset_data = subset_data

    def __call__(self, chunk_or_series_from_chunk: Union[DataFrame, Series], *args, **kwargs):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        kwargs['chunk_parent'] = self._get_parent(chunk_or_series_from_chunk)
        return self._style_func(chunk_or_series_from_chunk, *args, **kwargs)

    def _get_parent(self, chunk_or_series_from_chunk: Union[DataFrame, Series]):
        if self._axis == 0 or self._axis == "index":
            return self._subset_data[chunk_or_series_from_chunk.name]
        elif self._axis == 1 or self._axis == "columns":
            return self._subset_data.loc[chunk_or_series_from_chunk.name]
        else:
            return self._subset_data

from typing import Optional, Union

import numpy as np
from pandas import DataFrame, Series
from pandas.io.formats.style import _validate_apply_axis_arg


class HighlightBetweenPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo):
        super().__init__(df, todo)

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        return self._todo.builder() \
            .with_subset(self._calculate_chunk_subset(chunk)) \
            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, self._subset_data)) \
            .build()

    def _styling_func(self,
                      chunk_or_series_from_chunk: Union[DataFrame, Series],
                      chunk_parent: Union[DataFrame, Series],
                      **kwargs,
                      ):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        left = kwargs.get("left", None)
        right = kwargs.get("right", None)

        if np.iterable(left) and not isinstance(left, str):
            left = _validate_apply_axis_arg(left, "left", None, chunk_parent)
            left = self._adjust_range_part(left, chunk_or_series_from_chunk, chunk_parent)

        if np.iterable(right) and not isinstance(right, str):
            right = _validate_apply_axis_arg(right, "right", None, chunk_parent)
            right = self._adjust_range_part(right, chunk_or_series_from_chunk, chunk_parent)

        return self._todo.apply_args.style_func(
            chunk_or_series_from_chunk,
            **dict(kwargs, left=left, right=right),
        )

    def _adjust_range_part(self, part, chunk, chunk_parent):
        if isinstance(chunk, Series):
            return part[chunk_parent.index.get_indexer_for(chunk.index)]
        elif isinstance(chunk, DataFrame) and self._todo.apply_args.axis is None:
            ri = chunk_parent.index.get_indexer_for(chunk.index)
            ci = chunk_parent.columns.get_indexer_for(chunk.columns)
            ri_slice = slice(ri[0], ri[-1] + 1)
            ci_slice = slice(ci[0], ci[-1] + 1)
            return part[ri_slice, ci_slice]
        raise ValueError(f"Unexpected chunk type:{type(chunk)} for axis:{str(self._todo.apply_args.axis)}")

import numpy as np
from typing import Optional, Union
from pandas import DataFrame, Series


class HighlightExtremaPatcher(TodoPatcher):

    def __init__(self, df: DataFrame, todo: StylerTodo, op: str):
        super().__init__(df, todo)
        self._op: str = op
        self._attribute: str = todo.style_func_kwargs.get('props', 'background-color: yellow')

    def create_patched_todo(self, chunk: DataFrame) -> Optional[StylerTodo]:
        return self._todo.builder() \
            .with_subset(self._calculate_chunk_subset(chunk)) \
            .with_style_func_kwargs({}) \
            .with_style_func(ChunkParentProvider(self._styling_func, self._todo.apply_args.axis, self._subset_data)) \
            .build()

    def _styling_func(self,
                      chunk_or_series_from_chunk: Union[DataFrame, Series],
                      chunk_parent: Union[DataFrame, Series],
                      ):
        if chunk_or_series_from_chunk.empty:
            return chunk_or_series_from_chunk

        value = getattr(chunk_parent, self._op)(skipna=True)

        if isinstance(chunk_or_series_from_chunk, DataFrame):  # min/max must be done twice to return scalar
            value = getattr(value, self._op)(skipna=True)
        return np.where(chunk_or_series_from_chunk == value, self._attribute, "")

from typing import Callable, List, Tuple, Optional

from pandas import DataFrame
from pandas.io.formats.style import Styler


class TodosPatcher:

    def patch_todos_for_chunk(self, source: Styler, chunk: DataFrame) -> List[Tuple[Callable, tuple, dict]]:
        result: List[Tuple[Callable, tuple, dict]] = []

        for t in source._todo:
            todo = StylerTodo.from_tuple(t)

            if todo.is_pandas_style_func():
                patcher = self.__get_patcher_for_pandas_style_function(source.data, todo)
            else:
                if todo.is_applymap_call():
                    patcher = ApplyMapPatcher(source.data, todo)
                else:
                    patcher = ApplyPatcher(source.data, todo)

            if patcher is not None:
                result.append(patcher.create_patched_todo(chunk).to_tuple())

        return result

    @staticmethod
    def is_style_function_supported(todo: StylerTodo) -> bool:
        if todo.is_pandas_style_func():
            return TodosPatcher.__get_patcher_for_pandas_style_function(DataFrame(), todo) is not None
        return True

    @staticmethod
    def __get_patcher_for_pandas_style_function(df: DataFrame, todo: StylerTodo) -> Optional[TodoPatcher]:
        qname = StyleFunctionNameResolver.get_style_func_qname(todo)
        if StyleFunctionNameResolver.is_pandas_text_gradient(qname, todo):
            return BackgroundGradientPatcher(df, todo)
        elif StyleFunctionNameResolver.is_pandas_background_gradient(qname):
            return BackgroundGradientPatcher(df, todo)
        elif StyleFunctionNameResolver.is_pandas_highlight_max(qname, todo):
            return HighlightExtremaPatcher(df, todo, 'max')
        elif StyleFunctionNameResolver.is_pandas_highlight_min(qname, todo):
            return HighlightExtremaPatcher(df, todo, 'min')
        elif StyleFunctionNameResolver.is_pandas_highlight_null(qname):
            return ApplyPatcher(df, todo)
        elif StyleFunctionNameResolver.is_pandas_highlight_between(qname):
            return HighlightBetweenPatcher(df, todo)
        elif StyleFunctionNameResolver.is_pandas_set_properties(qname):
            return ApplyMapPatcher(df, todo)
        return None

from dataclasses import dataclass
from abc import abstractmethod, ABC
from typing import List, Tuple, Callable
from collections.abc import Mapping
from pandas import DataFrame
from pandas.io.formats.style import Styler


class _IndexTranslator(ABC):
    @abstractmethod
    def translate(self, index):
        pass


class _SequenceIndexTranslator(_IndexTranslator):
    def __init__(self, seq):
        super().__init__()
        self.__seq = seq

    def translate(self, index):
        return self.__seq[index]


class _OffsetIndexTranslator(_IndexTranslator):
    def __init__(self, offset: int):
        super().__init__()
        self.__offset = offset

    def translate(self, index):
        return index + self.__offset


class _TranslateKeysDict(Mapping):

    def __init__(self, org_dict: dict, translate_key: Callable):
        self._org_dict = org_dict
        self._translate_key = translate_key

    def get(self, key, default=None):
        t_key = self._translate_key(key)
        if t_key not in self._org_dict:
            return default
        return self._org_dict.get(t_key)

    def __contains__(self, key):
        return self._translate_key(key) in self._org_dict

    def __getitem__(self, key):
        return self._org_dict[self._translate_key(key)]

    def values(self):
        return super().values()

    def __iter__(self):
        raise NotImplementedError

    def keys(self):
        raise NotImplementedError

    def items(self):
        raise NotImplementedError

    def __len__(self):
        return len(self._org_dict)


class _HTMLPropsIndexAdjuster:

    def __init__(self, ri_translator: _IndexTranslator, ci_translator: _IndexTranslator):
        self.ri_translator = ri_translator
        self.ci_translator = ci_translator

    def adjust(self, d: dict):
        for head in d.get('head', []):
            for col in head:
                if 'id' in col:
                    col['id'] = '_'.join(self._adjust_indices(col['id'].split('_')))
                if 'class' in col:
                    col['class'] = ' '.join(self._adjust_indices(col['class'].strip().split(' ')))

        for row in d.get('body', []):
            for entry in row:
                if 'id' in entry:
                    entry['id'] = '_'.join(self._adjust_indices(entry['id'].split('_')))
                if 'class' in entry:
                    entry['class'] = ' '.join(self._adjust_indices(entry['class'].strip().split(' ')))

        for style in d.get('cellstyle', []):
            if 'selectors' in style:
                style['selectors'] = ['_'.join(self._adjust_indices(s.split('_'))) for s in style['selectors']]

        if 'index_lengths' in d:
            d['index_lengths'] = {(k[0], self.ri_translator.translate(k[1])): v for k, v in d['index_lengths'].items()}

    def _adjust_indices(self, indices: List[str]) -> List[str]:
        return [self._adjust_index(x) for x in indices]

    def _adjust_index(self, index: str) -> str:
        if index.startswith("row") and index[3:].isdigit():
            return f'row{self.ri_translator.translate(int(index[3:]))}'
        if index.startswith("col") and index[3:].isdigit():
            return f'col{self.ci_translator.translate(int(index[3:]))}'
        return index


@dataclass(frozen=True)
class Region:
    first_row: int = 0
    first_col: int = 0
    rows: int = 0
    cols: int = 0

    def is_empty(self) -> bool:
        return self.rows == 0 or self.cols == 0

    def is_valid(self) -> bool:
        return self.first_row >= 0 and self.first_col >= 0 and self.rows >= 0 and self.cols >= 0


class HTMLPropsGenerator:
    def __init__(self, visible_data: DataFrame, styler: Styler):
        self.__visible_data: DataFrame = visible_data
        self.__styler: Styler = styler

    def create_html(self, html_props: dict) -> str:
        return self.__styler.template_html.render(
            **html_props,
            encoding="utf-8",
            sparse_columns=False,
            sparse_index=False,
            doctype_html=True,
            html_table_tpl=self.__styler.template_html_table,
            html_style_tpl=self.__styler.template_html_style,
        )

    def generate_props_unpatched(self) -> dict:
        copy = self.__styler._copy(deepcopy=True)
        copy.uuid = ''
        copy.uuid_len = 0
        copy.cell_ids = False
        copy._compute()
        return copy._translate(sparse_index=False, sparse_cols=False)

    def generate_props_for_chunk(self,
                                 region: Region,
                                 exclude_row_header: bool = False,
                                 exclude_col_header: bool = False,
                                 ) -> dict:
        chunk = self.__visible_data.iloc[
                region.first_row: region.first_row + region.rows,
                region.first_col: region.first_col + region.cols,
                ]

        patched_todos = TodosPatcher().patch_todos_for_chunk(self.__styler, chunk)

        computed_styler = self.__compute_styles(
            patched_todos=patched_todos,
            exclude_row_header=exclude_row_header,
            exclude_col_header=exclude_col_header,
        )

        if len(self.__styler.hidden_rows) == 0:
            rit = _OffsetIndexTranslator(region.first_row)
        else:
            rit = _SequenceIndexTranslator(self.__styler.index.get_indexer_for(chunk.index))

        if len(self.__styler.hidden_columns) == 0:
            cit = _OffsetIndexTranslator(region.first_col)
        else:
            cit = _SequenceIndexTranslator(self.__styler.columns.get_indexer_for(chunk.columns))

        chunk_styler = chunk.style
        self.__copy_styler_state(source=computed_styler, target=chunk_styler)

        def translate_key(k):
            return rit.translate(k[0]), cit.translate(k[1])

        chunk_styler.ctx = _TranslateKeysDict(computed_styler.ctx, translate_key)
        chunk_styler.cell_context = _TranslateKeysDict(computed_styler.cell_context, translate_key)
        chunk_styler._display_funcs = _TranslateKeysDict(computed_styler._display_funcs, translate_key)

        result = chunk_styler._translate(sparse_index=False, sparse_cols=False)

        _HTMLPropsIndexAdjuster(rit, cit).adjust(result)

        return result

    def __compute_styles(self,
                         patched_todos: List[Tuple[Callable, tuple, dict]],
                         exclude_row_header: bool = False,
                         exclude_col_header: bool = False,
                         ) -> Styler:
        copy = self.__styler.data.style
        self.__copy_styler_state(source=self.__styler, target=copy)

        copy._todo = patched_todos

        if exclude_row_header:
            copy.hide(axis="index")
        if exclude_col_header:
            copy.hide(axis="columns")

        copy._compute()
        return copy

    @staticmethod
    def __copy_styler_state(source: Styler, target: Styler):
        target.uuid = ''
        target.uuid_len = 0
        target.cell_ids = False

        target.table_styles = source.table_styles
        target.table_attributes = source.table_attributes
        target.hide_columns_ = source.hide_columns_
        target.hide_column_names = source.hide_column_names
        target.hide_index_ = source.hide_index_
        target.hide_index_names = source.hide_index_names
        target.cell_context = source.cell_context
        target._display_funcs = source._display_funcs

import json
from typing import Any
from pandas import DataFrame
from pandas.io.formats.style import Styler
from dataclasses import dataclass


class _MyJSONEncoder(json.JSONEncoder):
    def encode(self, obj: Any):
        return super().encode(self._sanitize_dict_keys(obj))

    def default(self, obj: Any) -> str:
        return str(obj)

    def _sanitize_dict_keys(self, obj: Any):
        if isinstance(obj, dict):
            result = {}
            for key, value in obj.items():
                new_key = key
                if key is not isinstance(key, (str, int, float, bool)):
                    new_key = str(key)
                result[new_key] = self._sanitize_dict_keys(value)
            return result
        if isinstance(obj, list):
            return [self._sanitize_dict_keys(v) for v in obj]
        return obj


def _jsonify_html_props(d: dict) -> str:
    copy = dict(d)
    if "cellstyle" in copy:
        copy["cellstyle"] = _map_by_css_selector(copy["cellstyle"])
    if "body" in copy:
        copy["body"] = _remove_hidden_row_entries(copy["body"])
    if "head" in copy:
        copy["head"] = _remove_hidden_row_entries(copy["head"])
    return json.dumps(copy, indent=2, sort_keys=True, cls=_MyJSONEncoder)


def _map_by_css_selector(cellstyle: list) -> dict:
    result = {}
    for entry in cellstyle:
        for s in entry.get('selectors', []):
            result[s] = entry['props']
    return result


def _remove_hidden_row_entries(rows: list) -> list:
    result = []
    all_empty = True
    for row in rows:
        visible_entries = list(filter(lambda e: e.get("is_visible", True), row))
        if all_empty:
            all_empty = len(visible_entries) == 0
        result.append(visible_entries)
    return [] if all_empty else result


@dataclass(frozen=True)
class HTMLPropsValidationResult:
    actual: str
    expected: str
    is_equal: bool


class AbstractHTMLPropsValidator:
    def __init__(self, html_props_generator: HTMLPropsGenerator):
        self._html_props_generator: HTMLPropsGenerator = html_props_generator

    def _validate_html_props(self,
                             actual_html_props: dict,
                             expected_html_props: dict,
                             write_html_on_error: bool = False,
                             ) -> HTMLPropsValidationResult:
        actual_json = _jsonify_html_props(actual_html_props)
        expected_json = _jsonify_html_props(expected_html_props)

        if actual_json != expected_json and write_html_on_error:
            self.__write_html(self._html_props_generator.create_html(actual_html_props), "actual.html")
            self.__write_html(self._html_props_generator.create_html(expected_html_props), "expected.html")

        return HTMLPropsValidationResult(actual_json, expected_json, actual_json == expected_json)

    @staticmethod
    def __write_html(html: str, file_name: str):
        with open(file_name, "w") as file:
            file.write(html)

    def _append_chunk_html_props(self, chunk_props: dict, target: dict, target_row_offset: int):
        unmerged_container_props = []
        for key in chunk_props.keys():
            if key == "uuid":
                target[key] = chunk_props[key]
            elif key == "caption":
                target[key] = chunk_props[key]
            elif key == "table_attributes":
                target[key] = chunk_props[key]
            elif key == "head":
                self._add_head_elements(chunk_props[key], target.setdefault(key, []))
            elif key == "body":
                self._add_body_elements(chunk_props[key], target.setdefault(key, []), target_row_offset)
            elif key == "cellstyle":
                self._add_new_list_entries(chunk_props[key], target.setdefault(key, []))
            elif key == "table_styles":
                self._add_new_list_entries(chunk_props[key], target.setdefault(key, []))
            elif key == "index_lengths":
                self._update_index_lengths(chunk_props[key], target.setdefault(key, {}))
            elif key == "cellstyle_columns":
                self._add_new_list_entries(chunk_props[key], target.setdefault(key, []))
            elif key == "cellstyle_index":
                self._add_new_list_entries(chunk_props[key], target.setdefault(key, []))
            else:
                if isinstance(chunk_props[key], (list, dict)):
                    unmerged_container_props.append(key)

        if len(unmerged_container_props) > 0:
            raise KeyError(f"Merge failed, unsupported keys {unmerged_container_props} found.")

    @staticmethod
    def _add_head_elements(source: list, target: list):
        assert isinstance(source, list)
        assert isinstance(target, list)

        if len(target) == 0:
            target.extend(source)
        else:
            for i, row in enumerate(source):
                if len(target) <= i:
                    target.append(row)
                else:
                    target_row = target[i]
                    for j, entry in enumerate(row):
                        if entry not in target_row:
                            target_row.extend(row[j:])
                            break

    @staticmethod
    def _add_body_elements(source: list, target: list, target_row_offset: int):
        assert isinstance(source, list)
        assert isinstance(target, list)

        if len(target) == 0:
            target.extend(source)
        else:
            for i, row in enumerate(source):
                if len(target) <= target_row_offset + i:
                    target.append(row)
                else:
                    target_row = target[target_row_offset + i]
                    for j, entry in enumerate(row):
                        if 'td' == entry.get("type", ""):
                            target_row.extend(row[j:])
                            break

    @staticmethod
    def _add_new_list_entries(source: list, target: list):
        assert isinstance(source, list)
        assert isinstance(target, list)

        if len(target) == 0:
            target.extend(source)
        else:
            for entry in source:
                if entry not in target:
                    target.append(entry)

    @staticmethod
    def _update_index_lengths(source: dict, target: dict):
        assert isinstance(source, dict)
        assert isinstance(target, dict)
        target.update(source)


class HTMLPropsValidator(AbstractHTMLPropsValidator):
    def __init__(self, visible_data: DataFrame, styler: Styler):
        super().__init__(HTMLPropsGenerator(visible_data, styler))
        self._visible_data: DataFrame = visible_data
        self._styler: Styler = styler

    def validate(self,
                 rows_per_chunk: int,
                 cols_per_chunk: int,
                 write_html_on_error: bool = False,
                 ) -> HTMLPropsValidationResult:
        rows_in_frame: int = len(self._visible_data.index)
        cols_in_frame: int = len(self._visible_data.columns)

        if rows_in_frame == 0 or cols_in_frame == 0:
            return HTMLPropsValidationResult('', '', True)

        combined_html_props = self._create_combined_html_props(rows_per_chunk, cols_per_chunk)
        expected_html_props = self._html_props_generator.generate_props_unpatched()

        return self._validate_html_props(combined_html_props, expected_html_props, write_html_on_error)

    def _create_combined_html_props(self, rows_per_chunk: int, cols_per_chunk: int):
        combined_props: dict = {}
        rows_in_frame: int = len(self._visible_data.index)
        cols_in_frame: int = len(self._visible_data.columns)

        rows_processed = 0
        while rows_processed < rows_in_frame:
            rows = min(rows_per_chunk, rows_in_frame - rows_processed)
            cols_in_row_processed = 0
            while cols_in_row_processed < cols_in_frame:
                cols = min(cols_per_chunk, cols_in_frame - cols_in_row_processed)
                chunk_html_props = self._html_props_generator.generate_props_for_chunk(
                    region=Region(rows_processed, cols_in_row_processed, rows, cols),
                    exclude_row_header=False,
                    exclude_col_header=False,
                )

                self._append_chunk_html_props(
                    chunk_props=chunk_html_props,
                    target=combined_props,
                    target_row_offset=rows_processed,
                )

                cols_in_row_processed += cols
            rows_processed += rows

        return combined_props

from dataclasses import dataclass, asdict
from enum import Enum
from typing import List, Callable, Tuple
from abc import ABC, abstractmethod
from pandas import DataFrame
from pandas.io.formats.style import Styler


class _StyleFunctionsHTMLPropsValidator(AbstractHTMLPropsValidator):
    def __init__(self, visible_data: DataFrame):
        super().__init__(HTMLPropsGenerator(visible_data, visible_data.style))
        self._visible_data: DataFrame = visible_data
        self._data_bounds: Region = Region(0, 0, len(visible_data.index), len(visible_data.columns))

    def validate(self,
                 todos: List[Tuple[Callable, tuple, dict]],
                 region: Region,
                 rows_per_chunk: int,
                 cols_per_chunk: int,
                 ) -> HTMLPropsValidationResult:

        sanitized_region = self._compute_sanitized_region(region)

        if sanitized_region.is_empty():
            return HTMLPropsValidationResult('', '', True)

        style = self._visible_data.style
        style._todo = todos
        self._html_props_generator = HTMLPropsGenerator(self._visible_data, style)

        combined_html_props = self._create_combined_html_props(
            region=sanitized_region,
            rows_per_chunk=rows_per_chunk,
            cols_per_chunk=cols_per_chunk,
        )

        expected_html_props = self._html_props_generator.generate_props_for_chunk(
            region=sanitized_region,
            exclude_row_header=False,
            exclude_col_header=False,
        )

        return self._validate_html_props(combined_html_props, expected_html_props)

    def _compute_sanitized_region(self, region: Region) -> Region:
        assert region.is_valid()
        if region.is_empty():
            return region
        elif self._data_bounds.is_empty():
            return self._data_bounds

        first_row = min(region.first_row, self._data_bounds.rows - 1)
        first_col = min(region.first_col, self._data_bounds.cols - 1)
        rows = min(region.rows, self._data_bounds.rows - first_row)
        cols = min(region.cols, self._data_bounds.cols - first_col)
        return Region(first_row, first_col, rows, cols)

    def _create_combined_html_props(self, region: Region, rows_per_chunk: int, cols_per_chunk: int):
        combined_props: dict = {}

        rows_processed = 0
        while rows_processed < region.rows:
            rows = min(rows_per_chunk, region.rows - rows_processed)
            cols_in_row_processed = 0
            while cols_in_row_processed < region.cols:
                cols = min(cols_per_chunk, region.cols - cols_in_row_processed)
                chunk_html_props = self._html_props_generator.generate_props_for_chunk(
                    region=Region(
                        region.first_row + rows_processed,
                        region.first_col + cols_in_row_processed,
                        rows,
                        cols,
                    ),
                    exclude_row_header=False,
                    exclude_col_header=False,
                )

                self._append_chunk_html_props(
                    chunk_props=chunk_html_props,
                    target=combined_props,
                    target_row_offset=rows_processed,
                )

                cols_in_row_processed += cols
            rows_processed += rows

        return combined_props


@dataclass(frozen=True)
class StyleFunctionValidationProblem:
    index: int
    reason: str
    message: str = ""

    def __str__(self):
        return str(asdict(self))


class ValidationStrategyType(Enum):
    FAST = "fast"
    PRECISION = "precision"


class _AbstractValidationStrategy(ABC):
    def __init__(self, strategy_type: ValidationStrategyType):
        self._strategy_type: ValidationStrategyType = strategy_type

    @property
    def strategy_type(self):
        return self._strategy_type

    @abstractmethod
    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:
        pass

    @staticmethod
    def _ceiling_division(n, d):
        return -(n // -d)


class _PrecisionValidationStrategy(_AbstractValidationStrategy):
    def __init__(self):
        super().__init__(ValidationStrategyType.PRECISION)

    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:
        cols_per_chunk = max(1, self._ceiling_division(rows_in_region, 2))
        rows_per_chunk = max(1, self._ceiling_division(columns_in_region, 2))
        return rows_per_chunk, cols_per_chunk


class _FastValidationStrategy(_AbstractValidationStrategy):

    def __init__(self):
        super().__init__(ValidationStrategyType.FAST)
        self.__split_vertical = True

    def get_chunk_size(self, rows_in_region: int, columns_in_region: int) -> Tuple[int, int]:
        rows_per_chunk = rows_in_region
        cols_per_chunk = columns_in_region

        if self.__split_vertical:
            cols_per_chunk = max(1, self._ceiling_division(cols_per_chunk, 2))
        else:
            rows_per_chunk = max(1, self._ceiling_division(rows_per_chunk, 2))

        self.__split_vertical = not self.__split_vertical
        return rows_per_chunk, cols_per_chunk


class StyleFunctionsValidator:

    def __init__(self, visible_data: DataFrame, styler: Styler):
        self.__visible_data: DataFrame = visible_data
        self.__styler: Styler = styler
        self.__validation_strategy: _AbstractValidationStrategy = _FastValidationStrategy()

    def set_validation_strategy_type(self, strategy_type: ValidationStrategyType):
        if self.__validation_strategy.strategy_type is strategy_type:
            return
        if strategy_type is ValidationStrategyType.FAST:
            self.__validation_strategy = _FastValidationStrategy()
        else:
            self.__validation_strategy = _PrecisionValidationStrategy()

    def validate(self, region: Region) -> List[StyleFunctionValidationProblem]:

        if len(self.__styler._todo) == 0:
            return []

        rows_per_chunk, cols_per_chunk = self.__validation_strategy.get_chunk_size(region.rows, region.cols)
        html_props_validator = _StyleFunctionsHTMLPropsValidator(self.__visible_data)

        if len(self.__styler._todo) == 1:
            return self.__validate_single_todos(html_props_validator, region, rows_per_chunk, cols_per_chunk)

        try:
            if html_props_validator.validate(self.__styler._todo, region, rows_per_chunk, cols_per_chunk).is_equal:
                return []
        except Exception:
            pass

        return self.__validate_single_todos(html_props_validator, region, rows_per_chunk, cols_per_chunk)

    def __validate_single_todos(self,
                                html_props_validator: _StyleFunctionsHTMLPropsValidator,
                                region: Region,
                                rows_per_chunk: int,
                                cols_per_chunk: int,
                                ) -> List[StyleFunctionValidationProblem]:
        validation_result = []

        for i, todo in enumerate(self.__styler._todo):
            try:
                result = html_props_validator.validate([todo], region, rows_per_chunk, cols_per_chunk)
                if not result.is_equal:
                    validation_result.append(StyleFunctionValidationProblem(i, "NOT_EQUAL"))
            except Exception as e:
                validation_result.append(StyleFunctionValidationProblem(i, "EXCEPTION", str(e)))

        return validation_result

from dataclasses import dataclass, asdict
import numpy as np  # numpy is required by pandas (therefore should be available at runtime)
from pandas import DataFrame
from pandas.io.formats.style import Styler
from typing import List, Optional


@dataclass(frozen=True)
class TableStructure:
    rows_count: int
    columns_count: int
    row_levels_count: int
    column_levels_count: int
    hide_row_header: bool
    hide_column_header: bool

    def __str__(self):
        return str(asdict(self))


@dataclass(frozen=True)
class StyleFunctionDetails:
    index: int
    qname: str
    resolved_name: str
    axis: str
    is_chunk_parent_requested: bool
    is_apply: bool
    is_pandas_builtin: bool
    is_supported: bool

    def __str__(self):
        return str(asdict(self))


class PatchedStyler:

    def __init__(self, styler: Styler):
        self.__styler: Styler = styler
        self.__visible_data: DataFrame = self.__get_visible_data(styler)
        self.__html_props_generator = HTMLPropsGenerator(self.__get_visible_data(styler), styler)
        self.__style_functions_validator = StyleFunctionsValidator(self.__get_visible_data(styler), styler)

    def create_html_props_validator(self) -> HTMLPropsValidator:
        return HTMLPropsValidator(self.__visible_data, self.__styler)

    def validate_style_functions(self,
                                 first_row: int,
                                 first_col: int,
                                 rows: int,
                                 cols: int,
                                 validation_strategy: Optional[ValidationStrategyType] = None,
                                 ) -> List[StyleFunctionValidationProblem]:
        if validation_strategy is not None:
            self.__style_functions_validator.set_validation_strategy_type(validation_strategy)
        return self.__style_functions_validator.validate(Region(first_row, first_col, rows, cols))

    def render_chunk(self,
                     first_row: int,
                     first_col: int,
                     rows: int,
                     cols: int,
                     exclude_row_header: bool = False,
                     exclude_col_header: bool = False
                     ) -> str:
        html_props = self.__html_props_generator.generate_props_for_chunk(
            region=Region(first_row, first_col, rows, cols),
            exclude_row_header=exclude_row_header,
            exclude_col_header=exclude_col_header,
        )
        return self.__html_props_generator.create_html(html_props)

    def render_unpatched(self) -> str:
        self.__styler.uuid = ''
        self.__styler.uuid_len = 0
        self.__styler.cell_ids = False
        return self.__styler.to_html(
            encoding="utf-8",
            doctype_html=True,
            sparse_columns=False,
            sparse_index=False,
        )

    def get_table_structure(self) -> TableStructure:
        return TableStructure(
            rows_count=len(self.__visible_data.index),
            columns_count=len(self.__visible_data.columns),
            row_levels_count=self.__visible_data.index.nlevels - self.__styler.hide_index_.count(True),
            column_levels_count=self.__visible_data.columns.nlevels - self.__styler.hide_columns_.count(True),
            hide_row_header=all(self.__styler.hide_index_),
            hide_column_header=all(self.__styler.hide_columns_)
        )

    def get_style_function_details(self) -> List[StyleFunctionDetails]:
        result = []

        for i, todo in enumerate(self.__styler._todo):
            t = StylerTodo.from_tuple(todo)
            result.append(StyleFunctionDetails(
                index=i,
                qname=StyleFunctionNameResolver.get_style_func_qname(t),
                resolved_name=StyleFunctionNameResolver.resolve_style_func_name(t),
                axis='' if not t.is_apply_call() else str(t.apply_args.axis),
                is_pandas_builtin=t.is_pandas_style_func(),
                is_supported=TodosPatcher.is_style_function_supported(t),
                is_apply=t.is_apply_call(),
                is_chunk_parent_requested=t.should_provide_chunk_parent(),
            ))

        return result

    @staticmethod
    def __get_visible_data(styler: Styler) -> DataFrame:
        if len(styler.hidden_rows) == 0 and len(styler.hidden_columns) == 0:
            return styler.data
        else:
            visible_indices = np.delete(styler.index.get_indexer_for(styler.index), styler.hidden_rows)
            visible_columns = np.delete(styler.columns.get_indexer_for(styler.columns), styler.hidden_columns)
            return styler.data.iloc[visible_indices, visible_columns]

from typing import Union

from pandas import DataFrame
from pandas.io.formats.style import Styler


class StyledDataFrameViewerBridge:
    patched_styler_refs = []

    @classmethod
    def create_patched_styler(cls, frame_or_styler: Union[DataFrame, Styler]) -> PatchedStyler:
        p = PatchedStyler(frame_or_styler.style) if isinstance(frame_or_styler, DataFrame) else PatchedStyler(
            frame_or_styler)
        cls.patched_styler_refs.append(p)
        return p

    @classmethod
    def delete_patched_styler(cls, patched_styler: PatchedStyler):
        cls.patched_styler_refs.remove(patched_styler)

    @classmethod
    def delete_all(cls):
        cls.patched_styler_refs.clear()

    @staticmethod
    def check() -> bool:
        return True
