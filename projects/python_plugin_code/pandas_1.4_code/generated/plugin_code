
from typing import Callable, Tuple, Optional
from pandas._typing import Axis
from pandas.io.formats.style_render import Subset


class ApplyArgs:

    def __init__(self, args: Tuple[Callable, Optional[Axis], Optional[Subset]]):
        self.__args = args

    def func(self) -> Callable:
        return self.__args[0]

    def axis(self) -> Optional[Axis]:
        return self.__args[1]

    def subset(self) -> Optional[Subset]:
        return self.__args[2]

from pandas import DataFrame
from pandas.io.formats.style import Styler
from typing import Any, Optional
from pandas.io.formats.style_render import non_reducing_slice, Subset


class BaseApplyPatcher:

    def __init__(self, data: DataFrame, apply_args: ApplyArgs, func_kwargs: dict):
        self._apply_args = apply_args
        self._func_kwargs = func_kwargs
        self._subset_data = self._evaluate_subset_data(data, apply_args.subset())

    def apply_to_styler(self, chunk_styler: Styler):
        chunk_subset = self._evaluate_chunk_subset(chunk_styler.data)
        chunk_styler.apply(self._exec_patched_func, axis=self._apply_args.axis(), subset=chunk_subset)

    def _exec_patched_func(self, chunk: DataFrame) -> Any:
        pass

    @staticmethod
    def _evaluate_subset_data(data: DataFrame, subset: Optional[Subset]) -> DataFrame:
        subset = slice(None) if subset is None else subset
        subset = non_reducing_slice(subset)
        return data.loc[subset]

    def _evaluate_chunk_subset(self, chunk: DataFrame) -> Optional[Subset]:
        chunk_subset = None
        if self._apply_args.subset() is not None:
            chunk_subset = (
                chunk.index.intersection(self._subset_data.index),
                chunk.columns.intersection(self._subset_data.columns))
        return chunk_subset

    def _get_parent(self, chunk: DataFrame):
        axis = self._apply_args.axis()
        if axis == 0 or axis == "index":
            return self._subset_data[chunk.name]
        elif axis == 1 or axis == "columns":
            return self._subset_data.loc[chunk.name]
        else:
            return self._subset_data

    def _get_key(self, chunk: DataFrame) -> str:
        axis = self._apply_args.axis()
        if axis == 0 or axis == "index":
            return chunk.name
        elif axis == 1 or axis == "columns":
            return chunk.name
        else:
            return "______df"

from pandas import DataFrame
import inspect


class ApplyFallbackPatch(BaseApplyPatcher):

    def __init__(self, data: DataFrame, apply_args: ApplyArgs, func_kwargs: dict):
        BaseApplyPatcher.__init__(self, data, apply_args, func_kwargs)
        self.__provide_chunk_parent = self._should_provide_chunk_parent()

    def _exec_patched_func(self, chunk: DataFrame):
        if self.__provide_chunk_parent:
            return self._apply_args.func()(chunk, **dict(self._func_kwargs, chunk_parent=self._get_parent(chunk)))
        else:
            return self._apply_args.func()(chunk, **self._func_kwargs)

    def _should_provide_chunk_parent(self):
        sig = inspect.signature(self._apply_args.func())
        for param in sig.parameters.values():
            if param.name == "chunk_parent" or param.kind == inspect.Parameter.VAR_KEYWORD:
                return True
        return False

from typing import Callable, Tuple, Optional
from pandas.io.formats.style_render import Subset


class ApplyMapArgs:

    def __init__(self, args: Tuple[Callable, Optional[Subset]]):
        self.__args = args

    def func(self) -> Callable:
        return self.__args[0]

    def subset(self) -> Optional[Subset]:
        return self.__args[1]

import pandas as pd
from typing import Optional
from pandas.io.formats.style import Styler
from pandas import DataFrame
from pandas.io.formats.style_render import (
    non_reducing_slice, Subset,
)


class BaseApplyMapPatcher:

    def __init__(self, data: DataFrame, _apply_args: ApplyMapArgs, func_kwargs: dict):
        self._apply_args = _apply_args
        self._func_kwargs = func_kwargs
        self._subset_data = self._evaluate_subset_data(data, _apply_args.subset())

    def apply_to_styler(self, chunk_styler: Styler):
        chunk_subset = self._evaluate_chunk_subset(chunk_styler.data)
        chunk_styler.applymap(self._exec_patched_func, subset=chunk_subset)

    @staticmethod
    def _evaluate_subset_data(data: DataFrame, subset: Optional[Subset]) -> DataFrame:
        if subset is None:
            subset = pd.IndexSlice[:]
        subset = non_reducing_slice(subset)
        return data.loc[subset]

    def _evaluate_chunk_subset(self, chunk: DataFrame) -> Optional[Subset]:
        chunk_subset = None
        if self._apply_args.subset() is not None:
            chunk_subset = (
                chunk.index.intersection(self._subset_data.index),
                chunk.columns.intersection(self._subset_data.columns))
        return chunk_subset

    def _exec_patched_func(self, scalar):
        pass

from pandas import DataFrame


class ApplyMapFallbackPatch(BaseApplyMapPatcher):

    def __init__(self, data: DataFrame, apply_args: ApplyMapArgs, func_kwargs: dict):
        BaseApplyMapPatcher.__init__(self, data, apply_args, func_kwargs)

    def _exec_patched_func(self, scalar):
        return self._apply_args.func()(scalar, **self._func_kwargs)

import numpy as np
import pandas as pd
from pandas.io.formats.style import _validate_apply_axis_arg


class BackgroundGradientPatch(BaseApplyPatcher):

    def __init__(self, data: pd.DataFrame, apply_args: ApplyArgs, func_kwargs: dict):
        BaseApplyPatcher.__init__(self, data, apply_args, func_kwargs)

    def _exec_patched_func(self, chunk: pd.DataFrame):


        vmin = self._func_kwargs.get("vmin", None)
        vmax = self._func_kwargs.get("vmax", None)
        gmap = self._func_kwargs.get("gmap", None)

        chunk_parent = self._get_parent(chunk)

        if gmap is None:
            gmap = chunk_parent.to_numpy(dtype=float)
        else:
            gmap = _validate_apply_axis_arg(gmap, "gmap", float, chunk_parent)

        if vmin is None or vmax is None:
            if vmin is None:
                vmin = np.nanmin(gmap)
            if vmax is None:
                vmax = np.nanmax(gmap)

        if chunk.empty:
            gmap = chunk
        elif isinstance(chunk, pd.Series):
            gmap = gmap[chunk_parent.index.get_indexer_for(chunk.index)]
        elif isinstance(chunk, pd.DataFrame) and self._apply_args.axis() is None:
            ri = chunk_parent.index.get_indexer_for(chunk.index)
            ci = chunk_parent.columns.get_indexer_for(chunk.columns)
            if isinstance(gmap, pd.DataFrame):
                gmap = gmap.iloc[(ri, ci)]
            elif isinstance(gmap, np.ndarray):
                gmap = pd.DataFrame(data=gmap, index=chunk_parent.index, columns=chunk_parent.columns)
                gmap = gmap.iloc[(ri, ci)]

        return self._apply_args.func()(chunk, **dict(self._func_kwargs, vmin=vmin, vmax=vmax, gmap=gmap))

import numpy as np
from typing import Optional
from pandas import DataFrame
from pandas.io.formats.style_render import (
    non_reducing_slice, Subset,
)


class HighlightExtremaPatch(BaseApplyPatcher):

    def __init__(self, data: DataFrame, apply_args: ApplyArgs, func_kwargs: dict, is_max: bool):
        BaseApplyPatcher.__init__(self, data, apply_args, func_kwargs)
        self.__attribute = func_kwargs.get('props', 'background-color: yellow')
        self.__is_max = is_max

    def _exec_patched_func(self, chunk: DataFrame):
        chunk_parent = self._get_parent(chunk)
        op = 'max' if self.__is_max else 'min'
        value = getattr(chunk_parent, op)(skipna=True)
        if isinstance(chunk, DataFrame):  # min/max must be done twice to return scalar
            value = getattr(value, op)(skipna=True)
        return np.where(chunk == value, self.__attribute, "")

    @staticmethod
    def _evaluate_subset_data(data: DataFrame, subset: Optional[Subset]) -> DataFrame:
        if subset is None:
            return data
        else:
            subset = non_reducing_slice(subset)
        return data.loc[subset]

import numpy as np
import pandas as pd
from pandas.io.formats.style import _validate_apply_axis_arg


class HighlightBetweenPatch(BaseApplyPatcher):

    def __init__(self, data: pd.DataFrame, apply_args: ApplyArgs, func_kwargs: dict):
        BaseApplyPatcher.__init__(self, data, apply_args, func_kwargs)

    def _exec_patched_func(self, chunk: pd.DataFrame):

        left = self._func_kwargs.get("left", None)
        right = self._func_kwargs.get("right", None)

        chunk_parent = self._get_parent(chunk)

        if np.iterable(left) and not isinstance(left, str):
            left = _validate_apply_axis_arg(
                left, "left", None, chunk_parent
            )
            left = self.__adjust_range_part(left, chunk, chunk_parent)

        if np.iterable(right) and not isinstance(right, str):
            right = _validate_apply_axis_arg(
                right, "right", None, chunk_parent
            )
            right = self.__adjust_range_part(right, chunk, chunk_parent)

        return self._apply_args.func()(chunk, **dict(self._func_kwargs, left=left, right=right))

    def __adjust_range_part(
            self,
            part,
            chunk,
            chunk_parent,
    ):
        if isinstance(chunk, pd.Series):
            return part[chunk_parent.index.get_indexer_for(chunk.index)]
        elif isinstance(chunk, pd.DataFrame) and self._apply_args.axis() is None:
            ri = chunk_parent.index.get_indexer_for(chunk.index)
            ci = chunk_parent.columns.get_indexer_for(chunk.columns)
            ri_slice = slice(ri[0], ri[-1] + 1)
            ci_slice = slice(ci[0], ci[-1] + 1)
            return part[ri_slice, ci_slice]

from typing import Tuple, Callable, cast, Optional
from pandas._typing import Axis
from pandas.io.formats.style_render import Subset


class ExportedStyle:
    def __init__(self, args: Tuple[Callable, tuple, dict]):
        self.__args = args

    def apply_func(self) -> Callable:
        return self.__args[0]

    def apply_args(self) -> tuple:
        return self.__args[1]

    def apply_args_func(self) -> Callable:
        return self.__args[1][0]

    def create_apply_args(self) -> ApplyArgs:
        return ApplyArgs(cast(Tuple[Callable, Optional[Axis], Optional[Subset]], self.__args[1]))

    def create_apply_map_args(self) -> ApplyMapArgs:
        return ApplyMapArgs(cast(Tuple[Callable, Optional[Subset]], self.__args[1]))

    def apply_kwargs(self) -> dict:
        return self.__args[2]

class TableStructure:
    def __init__(self,
                 rows_count: int,
                 columns_count: int,
                 visible_rows_count: int,
                 visible_columns_count: int,
                 row_levels_count: int,
                 column_levels_count: int,
                 hide_row_header: bool,
                 hide_column_header: bool):
        self.rows_count = rows_count
        self.columns_count = columns_count
        self.visible_rows_count = visible_rows_count
        self.visible_columns_count = visible_columns_count
        self.row_levels_count = row_levels_count
        self.column_levels_count = column_levels_count
        self.hide_row_header = hide_row_header
        self.hide_column_header = hide_column_header

import inspect
import numpy as np
from pandas import DataFrame
from pandas.io.formats.style import Styler
from typing import Callable, List, Tuple, Union
from functools import partial


class PatchedStyler:

    def __init__(self, styler: Styler):
        self.__styler = styler
        self.__visible_df = self.__get_visible_df(styler)
        self.__patched_styles = self.__patch_styles(styler.export())

    def render_chunk(
            self,
            first_row: int,
            first_column: int,
            last_row: int,
            last_column: int,
            exclude_row_header: bool = False,
            exclude_column_header: bool = False
    ) -> str:
        chunk: DataFrame = self.__visible_df.iloc[first_row:last_row, first_column:last_column]
        chunk_styler = chunk.style
        self.__apply_styler_configurations(self.__styler, chunk_styler)
        self.__prevent_unnecessary_html(chunk_styler)
        if exclude_row_header:
            chunk_styler.hide_index()
        if exclude_column_header:
            chunk_styler.hide_columns()
        for p in self.__patched_styles:
            p.apply_to_styler(chunk_styler)
        return self.__create_html(chunk_styler, first_row, first_column)

    def __create_html(self, chunk_styler, first_row: int, first_column: int) -> str:
        body = f'<body>{chunk_styler.render(encoding="utf-8")}</body>'
        chunk_df = chunk_styler.data
        if len(self.__styler.hidden_rows) == 0:
            meta_ri = f'<meta name="row_indexer" content="{first_row}" />'
        else:
            meta_ri = f'<meta name="row_indexer" content="{self.__styler.index.get_indexer_for(chunk_df.index)}" />'
        if len(self.__styler.hidden_columns) == 0:
            meta_ci = f'<meta name="col_indexer" content="{first_column}" />'
        else:
            meta_ci = f'<meta name="col_indexer" content="{self.__styler.columns.get_indexer_for(chunk_df.columns)}" />'
        head = f"<head>{meta_ri}{meta_ci}</head>"
        return f'<html>{head}{body}</html>'

    def render_unpatched(self) -> str:
        self.__prevent_unnecessary_html(self.__styler)
        return self.__styler.render(encoding="utf-8")

    def __patch_styles(self, styles: List[Tuple[Callable, tuple, dict]]) -> List[Union[BaseApplyPatcher, BaseApplyMapPatcher]]:
        patched_styles = []
        frame = self.__styler.data
        for t in styles:

            exported_style = ExportedStyle(t)
            apply_func = exported_style.apply_func()
            apply_kwargs = exported_style.apply_kwargs()
            apply_args_func = exported_style.apply_args_func()

            if self.__is_builtin_style(apply_args_func):
                qname = self.__get_qname(apply_args_func)
                if self.__is_builtin_background_gradient(qname):
                    patched_styles.append(
                        BackgroundGradientPatch(frame, exported_style.create_apply_args(), apply_kwargs)
                    )
                elif self.__is_builtin_highlight_max(qname, apply_args_func):
                    patched_styles.append(
                        HighlightExtremaPatch(frame, exported_style.create_apply_args(), apply_kwargs, True)
                    )
                elif self.__is_builtin_highlight_min(qname, apply_args_func):
                    patched_styles.append(
                        HighlightExtremaPatch(frame, exported_style.create_apply_args(), apply_kwargs, False)
                    )
                elif self.__is_builtin_highlight_null(qname):
                    patched_styles.append(
                        ApplyFallbackPatch(frame, exported_style.create_apply_args(), apply_kwargs)
                    )
                elif self.__is_builtin_highlight_between(qname):
                    patched_styles.append(
                        HighlightBetweenPatch(frame, exported_style.create_apply_args(), apply_kwargs)
                    )
                elif self.__is_builtin_set_properties(qname):
                    patched_styles.append(
                        ApplyMapFallbackPatch(frame, exported_style.create_apply_map_args(), apply_kwargs)
                    )
                continue
            elif self.__is_builtin_applymap(self.__get_qname(apply_func)):
                patched_styles.append(
                    ApplyMapFallbackPatch(frame, exported_style.create_apply_map_args(), apply_kwargs)
                )
            else:
                patched_styles.append(
                    ApplyFallbackPatch(frame, exported_style.create_apply_args(), apply_kwargs)
                )

        return patched_styles

    def get_table_structure(self) -> TableStructure:
        return TableStructure(
            rows_count=len(self.__styler.data.index),
            columns_count=len(self.__styler.data.columns),
            visible_rows_count=len(self.__visible_df.index),
            visible_columns_count=len(self.__visible_df.columns),
            row_levels_count=self.__visible_df.index.nlevels,
            column_levels_count=self.__visible_df.columns.nlevels,
            hide_row_header=self.__styler.hide_index_,
            hide_column_header=self.__styler.hide_columns_
        )

    @staticmethod
    def __get_visible_df(styler: Styler) -> DataFrame:
        if len(styler.hidden_rows) == 0 and len(styler.hidden_columns) == 0:
            return styler.data
        else:
            visible_indices = np.delete(styler.index.get_indexer_for(styler.index), styler.hidden_rows)
            visible_columns = np.delete(styler.columns.get_indexer_for(styler.columns), styler.hidden_columns)
            return styler.data.iloc[visible_indices, visible_columns]

    @staticmethod
    def __prevent_unnecessary_html(styler: Styler):
        styler.set_uuid("")
        styler.cell_ids = False

    @staticmethod
    def __is_builtin_style(func: Callable) -> bool:
        if isinstance(func, partial):
            func = func.func
        inspect_result = inspect.getmodule(func)
        return False if inspect_result is None else inspect.getmodule(func).__name__ == 'pandas.io.formats.style'

    @staticmethod
    def __get_qname(func: Callable) -> str:
        if isinstance(func, partial):
            func = func.func
        return getattr(func, '__qualname__', '')

    @staticmethod
    def __is_builtin_background_gradient(func_qname: str) -> bool:
        return func_qname == '_background_gradient'

    @staticmethod
    def __is_builtin_highlight_max(func_qname: str, func: Callable) -> bool:
        if isinstance(func, partial):
            return func_qname == '_highlight_value' and func.keywords.get('op', '') == 'max'
        else:
            return func_qname.startswith('Styler.highlight_max')

    @staticmethod
    def __is_builtin_highlight_min(func_qname: str, func: Callable) -> bool:
        if isinstance(func, partial):
            return func_qname == '_highlight_value' and func.keywords.get('op', '') == 'min'
        else:
            return func_qname.startswith('Styler.highlight_min')

    @staticmethod
    def __is_builtin_highlight_null(func_qname: str) -> bool:
        return func_qname.startswith('Styler.highlight_null')

    @staticmethod
    def __is_builtin_highlight_between(func_qname: str) -> bool:
        return func_qname == '_highlight_between'

    @staticmethod
    def __is_builtin_set_properties(func_qname: str) -> bool:
        return func_qname.startswith('Styler.set_properties')

    @staticmethod
    def __is_builtin_applymap(func_qname: str) -> bool:
        return func_qname.startswith('Styler.applymap')

    @staticmethod
    def __apply_styler_configurations(source_styler: Styler, chunk_styler: Styler):
        chunk_styler.hide_index_ = source_styler.hide_index_
        chunk_styler.hide_columns_ = source_styler.hide_columns_

        has_display_funcs = source_styler._display_funcs is not None and len(source_styler._display_funcs) > 0
        has_cell_content = source_styler.cell_context is not None and len(source_styler.cell_context) > 0

        should_copy = has_display_funcs or has_cell_content

        if should_copy:
            ri = source_styler.index.get_indexer_for(chunk_styler.index)
            ci = source_styler.columns.get_indexer_for(chunk_styler.columns)
            for c_index_in_chunk, c_index_in_source in enumerate(ci):
                for r_index_in_chunk, r_index_in_source in enumerate(ri):
                    target_key = (r_index_in_chunk, c_index_in_chunk)
                    source_key = (r_index_in_source, c_index_in_source)

                    if has_display_funcs and source_key in source_styler._display_funcs:
                        chunk_styler._display_funcs[target_key] = source_styler._display_funcs[source_key]

                    if has_cell_content and source_key in source_styler.cell_context:
                        chunk_styler.cell_context[target_key] = source_styler.cell_context[source_key]

import pandas as pd


class StyledDataFrameViewerBridge:
    patched_styler_refs = []

    @classmethod
    def create_patched_styler(cls, frame_or_styler) -> PatchedStyler:
        p = PatchedStyler(frame_or_styler.style) if isinstance(frame_or_styler, pd.DataFrame) else PatchedStyler(
            frame_or_styler)
        cls.patched_styler_refs.append(p)
        return p

    @classmethod
    def delete_patched_styler(cls, patched_styler: PatchedStyler):
        cls.patched_styler_refs.remove(patched_styler)

    @classmethod
    def delete_all(cls):
        cls.patched_styler_refs.clear()

    @staticmethod
    def check() -> bool:
        return True
