{
    "cms_rendner_sdfv": {
        "base": {
            "table_source": "import inspect\nimport typing\nfrom abc import ABC, abstractmethod\nfrom typing import Any, List, Optional, Union\n\nfrom cms_rendner_sdfv.base.transforms import to_json\nfrom cms_rendner_sdfv.base.types import CreateTableSourceConfig, CreateTableSourceFailure, Region, TableFrame, \\\n    TableSourceKind, TableStructure\n\n\nclass AbstractTableFrameGenerator(ABC):\n    @abstractmethod\n    def _region_or_region_of_frame(self, region: Region = None) -> Region:\n        pass\n\n    @abstractmethod\n    def generate(self,\n                 region: Region = None,\n                 exclude_row_header: bool = False,\n                 exclude_col_header: bool = False,\n                 ) -> TableFrame:\n        pass\n\n    def generate_by_combining_chunks(self,\n                                     rows_per_chunk: int,\n                                     cols_per_chunk: int,\n                                     region: Region = None,\n                                     ) -> TableFrame:\n        result = None\n\n        region = self._region_or_region_of_frame(region)\n\n        for chunk_region in region.iterate_chunkwise(rows_per_chunk, cols_per_chunk):\n\n            exclude_row_header = chunk_region.first_col > 0\n            exclude_col_header = chunk_region.first_row > 0\n\n            chunk_table = self.generate(\n                region=Region(\n                    region.first_row + chunk_region.first_row,\n                    region.first_col + chunk_region.first_col,\n                    chunk_region.rows,\n                    chunk_region.cols,\n                ),\n                exclude_row_header=exclude_row_header,\n                exclude_col_header=exclude_col_header,\n            )\n\n            if result is None:\n                result = chunk_table\n            else:\n                if not exclude_col_header:\n                    result.column_labels.extend(chunk_table.column_labels)\n                if not exclude_row_header:\n                    result.index_labels.extend(chunk_table.index_labels)\n                    result.cells.extend(chunk_table.cells)\n                else:\n                    for i, row in enumerate(chunk_table.cells):\n                        result.cells[i + chunk_region.first_row].extend(row)\n\n        return result if result is not None else TableFrame(index_labels=[], column_labels=[], legend=None, cells=[])\n\n\nclass AbstractTableSourceContext(ABC):\n    def set_sort_criteria(self, sort_by_column_index: Optional[List[int]], sort_ascending: Optional[List[bool]]):\n        pass\n\n    def get_org_indices_of_visible_columns(self, part_start: int, max_columns: int) -> List[int]:\n        pass\n\n    @abstractmethod\n    def get_region_of_frame(self) -> Region:\n        pass\n\n    @abstractmethod\n    def compute_frame_intersection(self, region: Region) -> Region:\n        pass\n\n    @abstractmethod\n    def get_table_structure(self, fingerprint: str) -> TableStructure:\n        pass\n\n    @abstractmethod\n    def get_table_frame_generator(self) -> AbstractTableFrameGenerator:\n        pass\n\n\nT = typing.TypeVar('T', bound=AbstractTableSourceContext)\n\n\nclass AbstractTableSource(ABC):\n    def __init__(self, kind: TableSourceKind, context: T, fingerprint: str):\n        self._kind = kind\n        self._context = context\n        self._fingerprint = fingerprint\n\n    def get_kind(self) -> TableSourceKind:\n        return self._kind\n\n    @staticmethod\n    def jsonify(data: Any) -> str:\n        return to_json(data)\n\n    def get_org_indices_of_visible_columns(self, part_start: int, max_columns: int) -> List[int]:\n        return self._context.get_org_indices_of_visible_columns(part_start, max_columns)\n\n    def get_table_structure(self) -> TableStructure:\n        return self._context.get_table_structure(self._fingerprint)\n\n    def set_sort_criteria(self,\n                          by_column_index: Optional[List[int]] = None,\n                          ascending: Optional[List[bool]] = None,\n                          ):\n        self._context.set_sort_criteria(by_column_index, ascending)\n\n    def compute_chunk_table_frame(self,\n                                  first_row: int,\n                                  first_col: int,\n                                  rows: int,\n                                  cols: int,\n                                  exclude_row_header: bool = False,\n                                  exclude_col_header: bool = False\n                                  ) -> TableFrame:\n        return self._context.get_table_frame_generator().generate(\n            region=Region(first_row, first_col, rows, cols),\n            exclude_row_header=exclude_row_header,\n            exclude_col_header=exclude_col_header,\n        )\n\n\nclass AbstractTableSourceFactory(ABC):\n    def create(self,\n               data_source: Any,\n               create_config: Union[CreateTableSourceConfig, dict] = None,\n               ) -> Union[AbstractTableSource, str]:\n        try:\n            config = create_config\n\n            if isinstance(config, dict):\n                config = CreateTableSourceConfig(**config)\n            elif config is None:\n                config = CreateTableSourceConfig()\n\n            caller_globals = {}\n            caller_frame = inspect.currentframe().f_back\n            if caller_frame:\n                caller_globals.update(caller_frame.f_globals)\n                caller_globals.update(caller_frame.f_locals)\n\n            table_source = self._create_internal(data_source, config, caller_globals)\n            if not isinstance(table_source, AbstractTableSource):\n                if isinstance(table_source, CreateTableSourceFailure):\n                    return to_json(table_source)\n                expected_type = type(AbstractTableSource)\n                actual_type = type(table_source)\n                raise ValueError(\n                    f\"Created table_source is of type: {actual_type}, expected: ${expected_type}.\"\n                )\n\n            return table_source\n        except Exception as e:\n            return to_json(CreateTableSourceFailure(error_kind=\"EVAL_EXCEPTION\", info=repr(e)))\n\n    @abstractmethod\n    def _create_internal(self,\n                         data_source: Any,\n                         config: CreateTableSourceConfig,\n                         caller_globals: dict,\n                         ) -> Union[AbstractTableSource, CreateTableSourceFailure]:\n        pass\n",
            "transforms": "import json\nfrom dataclasses import asdict, is_dataclass\nfrom typing import Any\n\n\nclass _CustomJSONEncoder(json.JSONEncoder):\n    def default(self, obj: Any):\n        if is_dataclass(obj):\n            return asdict(obj)\n        return str(obj)\n\n\ndef to_json(data: Any, **kwargs) -> str:\n    return json.dumps(data, **kwargs, cls=_CustomJSONEncoder)\n",
            "types": "from dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\n\n\n@dataclass(frozen=True)\nclass TableStructure:\n    org_rows_count: int\n    org_columns_count: int\n    rows_count: int\n    columns_count: int\n    fingerprint: str\n\n\n@dataclass\nclass TableFrameCell:\n    value: str\n    css: Dict[str, str] = None\n\n\n@dataclass\nclass TableFrameLegend:\n    index: List[str]\n    column: List[str]\n\n\n@dataclass\nclass TableFrame:\n    index_labels: List[List[str]]\n    column_labels: List[List[str]]\n    cells: List[List[TableFrameCell]]\n    legend: Optional[TableFrameLegend] = None\n\n\n@dataclass(frozen=True)\nclass Region:\n    first_row: int = 0\n    first_col: int = 0\n    rows: int = 0\n    cols: int = 0\n\n    def is_empty(self) -> bool:\n        return self.rows == 0 or self.cols == 0\n\n    def is_valid(self) -> bool:\n        return self.first_row >= 0 and self.first_col >= 0 and self.rows >= 0 and self.cols >= 0\n\n    def iterate_chunkwise(self, rows_per_chunk: int, cols_per_chunk: int):\n        rows_processed = 0\n        while rows_processed < self.rows:\n            rows = min(rows_per_chunk, self.rows - rows_processed)\n            cols_in_row_processed = 0\n            while cols_in_row_processed < self.cols:\n                cols = min(cols_per_chunk, self.cols - cols_in_row_processed)\n\n                yield Region(rows_processed, cols_in_row_processed, rows, cols)\n\n                cols_in_row_processed += cols\n            rows_processed += rows\n\n\n@dataclass(frozen=True)\nclass SortCriteria:\n    by_column: Optional[List[int]] = None\n    ascending: Optional[List[bool]] = None\n\n    def is_empty(self) -> bool:\n        return not self.by_column\n\n    def __eq__(self, other):\n        if isinstance(other, SortCriteria):\n            def _equals(s: Optional[List[Any]], o: Optional[List[Any]]) -> bool:\n                return (not s and not o) or s == o\n\n            return _equals(self.by_column, other.by_column) and _equals(self.ascending, other.ascending)\n        return False\n\n\n@dataclass(frozen=True)\nclass CreateTableSourceConfig:\n    data_source_transform_hint: Optional[str] = None\n    previous_fingerprint: Optional[str] = None\n    filter_eval_expr: Optional[str] = None\n    filter_eval_expr_provide_frame: Optional[bool] = None\n\n\n@dataclass(frozen=True)\nclass CreateTableSourceFailure:\n    error_kind: str\n    info: str\n\n\nclass TableSourceKind(Enum):\n    TABLE_SOURCE = 1\n    PATCHED_STYLER = 2\n\n"
        }
    }
}